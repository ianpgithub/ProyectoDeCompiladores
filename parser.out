Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    BOOL
    ENDL
    FALSE
    LBRACKET
    OR
    RBRACKET
    READ
    TO
    TRUE
    WRITE

Grammar

Rule 0     S' -> program
Rule 1     program -> goto_main PROGRAM ID SEMICOLON VARS define_vars_global define_function main
Rule 2     goto_main -> empty
Rule 3     id_list -> ID COMMA id_list
Rule 4     id_list -> ID
Rule 5     define_vars_global -> type COLON id_list SEMICOLON define_vars_global
Rule 6     define_vars_global -> empty
Rule 7     type -> INT
Rule 8     type -> FLOAT
Rule 9     type -> STRING
Rule 10    define_function -> FUNCTION type ID parameters VARS define_vars_function LBRACE statute RBRACE endfunc define_function
Rule 11    define_function -> empty
Rule 12    endfunc -> empty
Rule 13    define_vars_function -> type COLON id_list SEMICOLON define_vars_function
Rule 14    define_vars_function -> empty
Rule 15    function -> ID LPAREN era_function expression RPAREN SEMICOLON
Rule 16    era_function -> empty
Rule 17    main -> MAIN LPAREN RPAREN LBRACE statute RBRACE
Rule 18    parameters -> LPAREN type COLON id_list RPAREN
Rule 19    statute -> assignation statute
Rule 20    statute -> decision statute
Rule 21    statute -> condition statute
Rule 22    statute -> return statute
Rule 23    statute -> function statute
Rule 24    statute -> empty
Rule 25    assignation -> ID EQUAL expression SEMICOLON
Rule 26    decision -> IF LPAREN expression_bool RPAREN THEN LBRACE statute RBRACE ELSE LBRACE def_else statute RBRACE
Rule 27    decision -> IF LPAREN expression_bool RPAREN THEN LBRACE statute RBRACE
Rule 28    def_else -> empty
Rule 29    condition -> WHILE LPAREN expression_bool_while RPAREN DO LBRACE statute RBRACE
Rule 30    expression_bool -> expression GREATERTHAN term
Rule 31    expression_bool -> expression SMALLERTHAN term
Rule 32    expression_bool -> expression EQUALTO term
Rule 33    expression_bool_while -> expression GREATERTHAN term
Rule 34    expression_bool_while -> expression SMALLERTHAN term
Rule 35    expression_bool_while -> expression EQUALTO term
Rule 36    return -> RETURN LPAREN expression RPAREN SEMICOLON
Rule 37    expression -> expression PLUS term
Rule 38    expression -> expression MINUS term
Rule 39    expression -> term
Rule 40    term -> term TIMES factor
Rule 41    term -> term DIVIDE factor
Rule 42    term -> factor
Rule 43    factor -> FLOAT
Rule 44    factor -> INT
Rule 45    factor -> STRING
Rule 46    factor -> function
Rule 47    factor -> ID
Rule 48    factor -> PLUS factor
Rule 49    factor -> MINUS factor
Rule 50    factor -> LPAREN expression RPAREN
Rule 51    empty -> <empty>

Terminals, with rules where they appear

BOOL                 : 
COLON                : 5 13 18
COMMA                : 3
DIVIDE               : 41
DO                   : 29
ELSE                 : 26
ENDL                 : 
EQUAL                : 25
EQUALTO              : 32 35
FALSE                : 
FLOAT                : 8 43
FUNCTION             : 10
GREATERTHAN          : 30 33
ID                   : 1 3 4 10 15 25 47
IF                   : 26 27
INT                  : 7 44
LBRACE               : 10 17 26 26 27 29
LBRACKET             : 
LPAREN               : 15 17 18 26 27 29 36 50
MAIN                 : 17
MINUS                : 38 49
OR                   : 
PLUS                 : 37 48
PROGRAM              : 1
RBRACE               : 10 17 26 26 27 29
RBRACKET             : 
READ                 : 
RETURN               : 36
RPAREN               : 15 17 18 26 27 29 36 50
SEMICOLON            : 1 5 13 15 25 36
SMALLERTHAN          : 31 34
STRING               : 9 45
THEN                 : 26 27
TIMES                : 40
TO                   : 
TRUE                 : 
VARS                 : 1 10
WHILE                : 29
WRITE                : 
error                : 

Nonterminals, with rules where they appear

assignation          : 19
condition            : 21
decision             : 20
def_else             : 26
define_function      : 1 10
define_vars_function : 10 13
define_vars_global   : 1 5
empty                : 2 6 11 12 14 16 24 28
endfunc              : 10
era_function         : 15
expression           : 15 25 30 31 32 33 34 35 36 37 38 50
expression_bool      : 26 27
expression_bool_while : 29
factor               : 40 41 42 48 49
function             : 23 46
goto_main            : 1
id_list              : 3 5 13 18
main                 : 1
parameters           : 10
program              : 0
return               : 22
statute              : 10 17 19 20 21 22 23 26 26 27 29
term                 : 30 31 32 33 34 35 37 38 39 40 41
type                 : 5 10 13 18

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . goto_main PROGRAM ID SEMICOLON VARS define_vars_global define_function main
    (2) goto_main -> . empty
    (51) empty -> .

    PROGRAM         reduce using rule 51 (empty -> .)

    program                        shift and go to state 1
    goto_main                      shift and go to state 2
    empty                          shift and go to state 3

state 1

    (0) S' -> program .



state 2

    (1) program -> goto_main . PROGRAM ID SEMICOLON VARS define_vars_global define_function main

    PROGRAM         shift and go to state 4


state 3

    (2) goto_main -> empty .

    PROGRAM         reduce using rule 2 (goto_main -> empty .)


state 4

    (1) program -> goto_main PROGRAM . ID SEMICOLON VARS define_vars_global define_function main

    ID              shift and go to state 5


state 5

    (1) program -> goto_main PROGRAM ID . SEMICOLON VARS define_vars_global define_function main

    SEMICOLON       shift and go to state 6


state 6

    (1) program -> goto_main PROGRAM ID SEMICOLON . VARS define_vars_global define_function main

    VARS            shift and go to state 7


state 7

    (1) program -> goto_main PROGRAM ID SEMICOLON VARS . define_vars_global define_function main
    (5) define_vars_global -> . type COLON id_list SEMICOLON define_vars_global
    (6) define_vars_global -> . empty
    (7) type -> . INT
    (8) type -> . FLOAT
    (9) type -> . STRING
    (51) empty -> .

    INT             shift and go to state 11
    FLOAT           shift and go to state 12
    STRING          shift and go to state 13
    FUNCTION        reduce using rule 51 (empty -> .)
    MAIN            reduce using rule 51 (empty -> .)

    define_vars_global             shift and go to state 8
    type                           shift and go to state 9
    empty                          shift and go to state 10

state 8

    (1) program -> goto_main PROGRAM ID SEMICOLON VARS define_vars_global . define_function main
    (10) define_function -> . FUNCTION type ID parameters VARS define_vars_function LBRACE statute RBRACE endfunc define_function
    (11) define_function -> . empty
    (51) empty -> .

    FUNCTION        shift and go to state 15
    MAIN            reduce using rule 51 (empty -> .)

    define_function                shift and go to state 14
    empty                          shift and go to state 16

state 9

    (5) define_vars_global -> type . COLON id_list SEMICOLON define_vars_global

    COLON           shift and go to state 17


state 10

    (6) define_vars_global -> empty .

    FUNCTION        reduce using rule 6 (define_vars_global -> empty .)
    MAIN            reduce using rule 6 (define_vars_global -> empty .)


state 11

    (7) type -> INT .

    COLON           reduce using rule 7 (type -> INT .)
    ID              reduce using rule 7 (type -> INT .)


state 12

    (8) type -> FLOAT .

    COLON           reduce using rule 8 (type -> FLOAT .)
    ID              reduce using rule 8 (type -> FLOAT .)


state 13

    (9) type -> STRING .

    COLON           reduce using rule 9 (type -> STRING .)
    ID              reduce using rule 9 (type -> STRING .)


state 14

    (1) program -> goto_main PROGRAM ID SEMICOLON VARS define_vars_global define_function . main
    (17) main -> . MAIN LPAREN RPAREN LBRACE statute RBRACE

    MAIN            shift and go to state 19

    main                           shift and go to state 18

state 15

    (10) define_function -> FUNCTION . type ID parameters VARS define_vars_function LBRACE statute RBRACE endfunc define_function
    (7) type -> . INT
    (8) type -> . FLOAT
    (9) type -> . STRING

    INT             shift and go to state 11
    FLOAT           shift and go to state 12
    STRING          shift and go to state 13

    type                           shift and go to state 20

state 16

    (11) define_function -> empty .

    MAIN            reduce using rule 11 (define_function -> empty .)


state 17

    (5) define_vars_global -> type COLON . id_list SEMICOLON define_vars_global
    (3) id_list -> . ID COMMA id_list
    (4) id_list -> . ID

    ID              shift and go to state 22

    id_list                        shift and go to state 21

state 18

    (1) program -> goto_main PROGRAM ID SEMICOLON VARS define_vars_global define_function main .

    $end            reduce using rule 1 (program -> goto_main PROGRAM ID SEMICOLON VARS define_vars_global define_function main .)


state 19

    (17) main -> MAIN . LPAREN RPAREN LBRACE statute RBRACE

    LPAREN          shift and go to state 23


state 20

    (10) define_function -> FUNCTION type . ID parameters VARS define_vars_function LBRACE statute RBRACE endfunc define_function

    ID              shift and go to state 24


state 21

    (5) define_vars_global -> type COLON id_list . SEMICOLON define_vars_global

    SEMICOLON       shift and go to state 25


state 22

    (3) id_list -> ID . COMMA id_list
    (4) id_list -> ID .

    COMMA           shift and go to state 26
    SEMICOLON       reduce using rule 4 (id_list -> ID .)
    RPAREN          reduce using rule 4 (id_list -> ID .)


state 23

    (17) main -> MAIN LPAREN . RPAREN LBRACE statute RBRACE

    RPAREN          shift and go to state 27


state 24

    (10) define_function -> FUNCTION type ID . parameters VARS define_vars_function LBRACE statute RBRACE endfunc define_function
    (18) parameters -> . LPAREN type COLON id_list RPAREN

    LPAREN          shift and go to state 29

    parameters                     shift and go to state 28

state 25

    (5) define_vars_global -> type COLON id_list SEMICOLON . define_vars_global
    (5) define_vars_global -> . type COLON id_list SEMICOLON define_vars_global
    (6) define_vars_global -> . empty
    (7) type -> . INT
    (8) type -> . FLOAT
    (9) type -> . STRING
    (51) empty -> .

    INT             shift and go to state 11
    FLOAT           shift and go to state 12
    STRING          shift and go to state 13
    FUNCTION        reduce using rule 51 (empty -> .)
    MAIN            reduce using rule 51 (empty -> .)

    type                           shift and go to state 9
    define_vars_global             shift and go to state 30
    empty                          shift and go to state 10

state 26

    (3) id_list -> ID COMMA . id_list
    (3) id_list -> . ID COMMA id_list
    (4) id_list -> . ID

    ID              shift and go to state 22

    id_list                        shift and go to state 31

state 27

    (17) main -> MAIN LPAREN RPAREN . LBRACE statute RBRACE

    LBRACE          shift and go to state 32


state 28

    (10) define_function -> FUNCTION type ID parameters . VARS define_vars_function LBRACE statute RBRACE endfunc define_function

    VARS            shift and go to state 33


state 29

    (18) parameters -> LPAREN . type COLON id_list RPAREN
    (7) type -> . INT
    (8) type -> . FLOAT
    (9) type -> . STRING

    INT             shift and go to state 11
    FLOAT           shift and go to state 12
    STRING          shift and go to state 13

    type                           shift and go to state 34

state 30

    (5) define_vars_global -> type COLON id_list SEMICOLON define_vars_global .

    FUNCTION        reduce using rule 5 (define_vars_global -> type COLON id_list SEMICOLON define_vars_global .)
    MAIN            reduce using rule 5 (define_vars_global -> type COLON id_list SEMICOLON define_vars_global .)


state 31

    (3) id_list -> ID COMMA id_list .

    SEMICOLON       reduce using rule 3 (id_list -> ID COMMA id_list .)
    RPAREN          reduce using rule 3 (id_list -> ID COMMA id_list .)


state 32

    (17) main -> MAIN LPAREN RPAREN LBRACE . statute RBRACE
    (19) statute -> . assignation statute
    (20) statute -> . decision statute
    (21) statute -> . condition statute
    (22) statute -> . return statute
    (23) statute -> . function statute
    (24) statute -> . empty
    (25) assignation -> . ID EQUAL expression SEMICOLON
    (26) decision -> . IF LPAREN expression_bool RPAREN THEN LBRACE statute RBRACE ELSE LBRACE def_else statute RBRACE
    (27) decision -> . IF LPAREN expression_bool RPAREN THEN LBRACE statute RBRACE
    (29) condition -> . WHILE LPAREN expression_bool_while RPAREN DO LBRACE statute RBRACE
    (36) return -> . RETURN LPAREN expression RPAREN SEMICOLON
    (15) function -> . ID LPAREN era_function expression RPAREN SEMICOLON
    (51) empty -> .

    ID              shift and go to state 42
    IF              shift and go to state 43
    WHILE           shift and go to state 44
    RETURN          shift and go to state 45
    RBRACE          reduce using rule 51 (empty -> .)

    statute                        shift and go to state 35
    assignation                    shift and go to state 36
    decision                       shift and go to state 37
    condition                      shift and go to state 38
    return                         shift and go to state 39
    function                       shift and go to state 40
    empty                          shift and go to state 41

state 33

    (10) define_function -> FUNCTION type ID parameters VARS . define_vars_function LBRACE statute RBRACE endfunc define_function
    (13) define_vars_function -> . type COLON id_list SEMICOLON define_vars_function
    (14) define_vars_function -> . empty
    (7) type -> . INT
    (8) type -> . FLOAT
    (9) type -> . STRING
    (51) empty -> .

    INT             shift and go to state 11
    FLOAT           shift and go to state 12
    STRING          shift and go to state 13
    LBRACE          reduce using rule 51 (empty -> .)

    type                           shift and go to state 46
    define_vars_function           shift and go to state 47
    empty                          shift and go to state 48

state 34

    (18) parameters -> LPAREN type . COLON id_list RPAREN

    COLON           shift and go to state 49


state 35

    (17) main -> MAIN LPAREN RPAREN LBRACE statute . RBRACE

    RBRACE          shift and go to state 50


state 36

    (19) statute -> assignation . statute
    (19) statute -> . assignation statute
    (20) statute -> . decision statute
    (21) statute -> . condition statute
    (22) statute -> . return statute
    (23) statute -> . function statute
    (24) statute -> . empty
    (25) assignation -> . ID EQUAL expression SEMICOLON
    (26) decision -> . IF LPAREN expression_bool RPAREN THEN LBRACE statute RBRACE ELSE LBRACE def_else statute RBRACE
    (27) decision -> . IF LPAREN expression_bool RPAREN THEN LBRACE statute RBRACE
    (29) condition -> . WHILE LPAREN expression_bool_while RPAREN DO LBRACE statute RBRACE
    (36) return -> . RETURN LPAREN expression RPAREN SEMICOLON
    (15) function -> . ID LPAREN era_function expression RPAREN SEMICOLON
    (51) empty -> .

    ID              shift and go to state 42
    IF              shift and go to state 43
    WHILE           shift and go to state 44
    RETURN          shift and go to state 45
    RBRACE          reduce using rule 51 (empty -> .)

    assignation                    shift and go to state 36
    statute                        shift and go to state 51
    decision                       shift and go to state 37
    condition                      shift and go to state 38
    return                         shift and go to state 39
    function                       shift and go to state 40
    empty                          shift and go to state 41

state 37

    (20) statute -> decision . statute
    (19) statute -> . assignation statute
    (20) statute -> . decision statute
    (21) statute -> . condition statute
    (22) statute -> . return statute
    (23) statute -> . function statute
    (24) statute -> . empty
    (25) assignation -> . ID EQUAL expression SEMICOLON
    (26) decision -> . IF LPAREN expression_bool RPAREN THEN LBRACE statute RBRACE ELSE LBRACE def_else statute RBRACE
    (27) decision -> . IF LPAREN expression_bool RPAREN THEN LBRACE statute RBRACE
    (29) condition -> . WHILE LPAREN expression_bool_while RPAREN DO LBRACE statute RBRACE
    (36) return -> . RETURN LPAREN expression RPAREN SEMICOLON
    (15) function -> . ID LPAREN era_function expression RPAREN SEMICOLON
    (51) empty -> .

    ID              shift and go to state 42
    IF              shift and go to state 43
    WHILE           shift and go to state 44
    RETURN          shift and go to state 45
    RBRACE          reduce using rule 51 (empty -> .)

    decision                       shift and go to state 37
    statute                        shift and go to state 52
    assignation                    shift and go to state 36
    condition                      shift and go to state 38
    return                         shift and go to state 39
    function                       shift and go to state 40
    empty                          shift and go to state 41

state 38

    (21) statute -> condition . statute
    (19) statute -> . assignation statute
    (20) statute -> . decision statute
    (21) statute -> . condition statute
    (22) statute -> . return statute
    (23) statute -> . function statute
    (24) statute -> . empty
    (25) assignation -> . ID EQUAL expression SEMICOLON
    (26) decision -> . IF LPAREN expression_bool RPAREN THEN LBRACE statute RBRACE ELSE LBRACE def_else statute RBRACE
    (27) decision -> . IF LPAREN expression_bool RPAREN THEN LBRACE statute RBRACE
    (29) condition -> . WHILE LPAREN expression_bool_while RPAREN DO LBRACE statute RBRACE
    (36) return -> . RETURN LPAREN expression RPAREN SEMICOLON
    (15) function -> . ID LPAREN era_function expression RPAREN SEMICOLON
    (51) empty -> .

    ID              shift and go to state 42
    IF              shift and go to state 43
    WHILE           shift and go to state 44
    RETURN          shift and go to state 45
    RBRACE          reduce using rule 51 (empty -> .)

    condition                      shift and go to state 38
    statute                        shift and go to state 53
    assignation                    shift and go to state 36
    decision                       shift and go to state 37
    return                         shift and go to state 39
    function                       shift and go to state 40
    empty                          shift and go to state 41

state 39

    (22) statute -> return . statute
    (19) statute -> . assignation statute
    (20) statute -> . decision statute
    (21) statute -> . condition statute
    (22) statute -> . return statute
    (23) statute -> . function statute
    (24) statute -> . empty
    (25) assignation -> . ID EQUAL expression SEMICOLON
    (26) decision -> . IF LPAREN expression_bool RPAREN THEN LBRACE statute RBRACE ELSE LBRACE def_else statute RBRACE
    (27) decision -> . IF LPAREN expression_bool RPAREN THEN LBRACE statute RBRACE
    (29) condition -> . WHILE LPAREN expression_bool_while RPAREN DO LBRACE statute RBRACE
    (36) return -> . RETURN LPAREN expression RPAREN SEMICOLON
    (15) function -> . ID LPAREN era_function expression RPAREN SEMICOLON
    (51) empty -> .

    ID              shift and go to state 42
    IF              shift and go to state 43
    WHILE           shift and go to state 44
    RETURN          shift and go to state 45
    RBRACE          reduce using rule 51 (empty -> .)

    return                         shift and go to state 39
    statute                        shift and go to state 54
    assignation                    shift and go to state 36
    decision                       shift and go to state 37
    condition                      shift and go to state 38
    function                       shift and go to state 40
    empty                          shift and go to state 41

state 40

    (23) statute -> function . statute
    (19) statute -> . assignation statute
    (20) statute -> . decision statute
    (21) statute -> . condition statute
    (22) statute -> . return statute
    (23) statute -> . function statute
    (24) statute -> . empty
    (25) assignation -> . ID EQUAL expression SEMICOLON
    (26) decision -> . IF LPAREN expression_bool RPAREN THEN LBRACE statute RBRACE ELSE LBRACE def_else statute RBRACE
    (27) decision -> . IF LPAREN expression_bool RPAREN THEN LBRACE statute RBRACE
    (29) condition -> . WHILE LPAREN expression_bool_while RPAREN DO LBRACE statute RBRACE
    (36) return -> . RETURN LPAREN expression RPAREN SEMICOLON
    (15) function -> . ID LPAREN era_function expression RPAREN SEMICOLON
    (51) empty -> .

    ID              shift and go to state 42
    IF              shift and go to state 43
    WHILE           shift and go to state 44
    RETURN          shift and go to state 45
    RBRACE          reduce using rule 51 (empty -> .)

    function                       shift and go to state 40
    statute                        shift and go to state 55
    assignation                    shift and go to state 36
    decision                       shift and go to state 37
    condition                      shift and go to state 38
    return                         shift and go to state 39
    empty                          shift and go to state 41

state 41

    (24) statute -> empty .

    RBRACE          reduce using rule 24 (statute -> empty .)


state 42

    (25) assignation -> ID . EQUAL expression SEMICOLON
    (15) function -> ID . LPAREN era_function expression RPAREN SEMICOLON

    EQUAL           shift and go to state 56
    LPAREN          shift and go to state 57


state 43

    (26) decision -> IF . LPAREN expression_bool RPAREN THEN LBRACE statute RBRACE ELSE LBRACE def_else statute RBRACE
    (27) decision -> IF . LPAREN expression_bool RPAREN THEN LBRACE statute RBRACE

    LPAREN          shift and go to state 58


state 44

    (29) condition -> WHILE . LPAREN expression_bool_while RPAREN DO LBRACE statute RBRACE

    LPAREN          shift and go to state 59


state 45

    (36) return -> RETURN . LPAREN expression RPAREN SEMICOLON

    LPAREN          shift and go to state 60


state 46

    (13) define_vars_function -> type . COLON id_list SEMICOLON define_vars_function

    COLON           shift and go to state 61


state 47

    (10) define_function -> FUNCTION type ID parameters VARS define_vars_function . LBRACE statute RBRACE endfunc define_function

    LBRACE          shift and go to state 62


state 48

    (14) define_vars_function -> empty .

    LBRACE          reduce using rule 14 (define_vars_function -> empty .)


state 49

    (18) parameters -> LPAREN type COLON . id_list RPAREN
    (3) id_list -> . ID COMMA id_list
    (4) id_list -> . ID

    ID              shift and go to state 22

    id_list                        shift and go to state 63

state 50

    (17) main -> MAIN LPAREN RPAREN LBRACE statute RBRACE .

    $end            reduce using rule 17 (main -> MAIN LPAREN RPAREN LBRACE statute RBRACE .)


state 51

    (19) statute -> assignation statute .

    RBRACE          reduce using rule 19 (statute -> assignation statute .)


state 52

    (20) statute -> decision statute .

    RBRACE          reduce using rule 20 (statute -> decision statute .)


state 53

    (21) statute -> condition statute .

    RBRACE          reduce using rule 21 (statute -> condition statute .)


state 54

    (22) statute -> return statute .

    RBRACE          reduce using rule 22 (statute -> return statute .)


state 55

    (23) statute -> function statute .

    RBRACE          reduce using rule 23 (statute -> function statute .)


state 56

    (25) assignation -> ID EQUAL . expression SEMICOLON
    (37) expression -> . expression PLUS term
    (38) expression -> . expression MINUS term
    (39) expression -> . term
    (40) term -> . term TIMES factor
    (41) term -> . term DIVIDE factor
    (42) term -> . factor
    (43) factor -> . FLOAT
    (44) factor -> . INT
    (45) factor -> . STRING
    (46) factor -> . function
    (47) factor -> . ID
    (48) factor -> . PLUS factor
    (49) factor -> . MINUS factor
    (50) factor -> . LPAREN expression RPAREN
    (15) function -> . ID LPAREN era_function expression RPAREN SEMICOLON

    FLOAT           shift and go to state 70
    INT             shift and go to state 71
    STRING          shift and go to state 72
    ID              shift and go to state 64
    PLUS            shift and go to state 66
    MINUS           shift and go to state 68
    LPAREN          shift and go to state 74

    expression                     shift and go to state 65
    term                           shift and go to state 67
    factor                         shift and go to state 69
    function                       shift and go to state 73

state 57

    (15) function -> ID LPAREN . era_function expression RPAREN SEMICOLON
    (16) era_function -> . empty
    (51) empty -> .

    FLOAT           reduce using rule 51 (empty -> .)
    INT             reduce using rule 51 (empty -> .)
    STRING          reduce using rule 51 (empty -> .)
    ID              reduce using rule 51 (empty -> .)
    PLUS            reduce using rule 51 (empty -> .)
    MINUS           reduce using rule 51 (empty -> .)
    LPAREN          reduce using rule 51 (empty -> .)

    era_function                   shift and go to state 75
    empty                          shift and go to state 76

state 58

    (26) decision -> IF LPAREN . expression_bool RPAREN THEN LBRACE statute RBRACE ELSE LBRACE def_else statute RBRACE
    (27) decision -> IF LPAREN . expression_bool RPAREN THEN LBRACE statute RBRACE
    (30) expression_bool -> . expression GREATERTHAN term
    (31) expression_bool -> . expression SMALLERTHAN term
    (32) expression_bool -> . expression EQUALTO term
    (37) expression -> . expression PLUS term
    (38) expression -> . expression MINUS term
    (39) expression -> . term
    (40) term -> . term TIMES factor
    (41) term -> . term DIVIDE factor
    (42) term -> . factor
    (43) factor -> . FLOAT
    (44) factor -> . INT
    (45) factor -> . STRING
    (46) factor -> . function
    (47) factor -> . ID
    (48) factor -> . PLUS factor
    (49) factor -> . MINUS factor
    (50) factor -> . LPAREN expression RPAREN
    (15) function -> . ID LPAREN era_function expression RPAREN SEMICOLON

    FLOAT           shift and go to state 70
    INT             shift and go to state 71
    STRING          shift and go to state 72
    ID              shift and go to state 64
    PLUS            shift and go to state 66
    MINUS           shift and go to state 68
    LPAREN          shift and go to state 74

    expression_bool                shift and go to state 77
    expression                     shift and go to state 78
    term                           shift and go to state 67
    factor                         shift and go to state 69
    function                       shift and go to state 73

state 59

    (29) condition -> WHILE LPAREN . expression_bool_while RPAREN DO LBRACE statute RBRACE
    (33) expression_bool_while -> . expression GREATERTHAN term
    (34) expression_bool_while -> . expression SMALLERTHAN term
    (35) expression_bool_while -> . expression EQUALTO term
    (37) expression -> . expression PLUS term
    (38) expression -> . expression MINUS term
    (39) expression -> . term
    (40) term -> . term TIMES factor
    (41) term -> . term DIVIDE factor
    (42) term -> . factor
    (43) factor -> . FLOAT
    (44) factor -> . INT
    (45) factor -> . STRING
    (46) factor -> . function
    (47) factor -> . ID
    (48) factor -> . PLUS factor
    (49) factor -> . MINUS factor
    (50) factor -> . LPAREN expression RPAREN
    (15) function -> . ID LPAREN era_function expression RPAREN SEMICOLON

    FLOAT           shift and go to state 70
    INT             shift and go to state 71
    STRING          shift and go to state 72
    ID              shift and go to state 64
    PLUS            shift and go to state 66
    MINUS           shift and go to state 68
    LPAREN          shift and go to state 74

    expression_bool_while          shift and go to state 79
    expression                     shift and go to state 80
    term                           shift and go to state 67
    factor                         shift and go to state 69
    function                       shift and go to state 73

state 60

    (36) return -> RETURN LPAREN . expression RPAREN SEMICOLON
    (37) expression -> . expression PLUS term
    (38) expression -> . expression MINUS term
    (39) expression -> . term
    (40) term -> . term TIMES factor
    (41) term -> . term DIVIDE factor
    (42) term -> . factor
    (43) factor -> . FLOAT
    (44) factor -> . INT
    (45) factor -> . STRING
    (46) factor -> . function
    (47) factor -> . ID
    (48) factor -> . PLUS factor
    (49) factor -> . MINUS factor
    (50) factor -> . LPAREN expression RPAREN
    (15) function -> . ID LPAREN era_function expression RPAREN SEMICOLON

    FLOAT           shift and go to state 70
    INT             shift and go to state 71
    STRING          shift and go to state 72
    ID              shift and go to state 64
    PLUS            shift and go to state 66
    MINUS           shift and go to state 68
    LPAREN          shift and go to state 74

    expression                     shift and go to state 81
    term                           shift and go to state 67
    factor                         shift and go to state 69
    function                       shift and go to state 73

state 61

    (13) define_vars_function -> type COLON . id_list SEMICOLON define_vars_function
    (3) id_list -> . ID COMMA id_list
    (4) id_list -> . ID

    ID              shift and go to state 22

    id_list                        shift and go to state 82

state 62

    (10) define_function -> FUNCTION type ID parameters VARS define_vars_function LBRACE . statute RBRACE endfunc define_function
    (19) statute -> . assignation statute
    (20) statute -> . decision statute
    (21) statute -> . condition statute
    (22) statute -> . return statute
    (23) statute -> . function statute
    (24) statute -> . empty
    (25) assignation -> . ID EQUAL expression SEMICOLON
    (26) decision -> . IF LPAREN expression_bool RPAREN THEN LBRACE statute RBRACE ELSE LBRACE def_else statute RBRACE
    (27) decision -> . IF LPAREN expression_bool RPAREN THEN LBRACE statute RBRACE
    (29) condition -> . WHILE LPAREN expression_bool_while RPAREN DO LBRACE statute RBRACE
    (36) return -> . RETURN LPAREN expression RPAREN SEMICOLON
    (15) function -> . ID LPAREN era_function expression RPAREN SEMICOLON
    (51) empty -> .

    ID              shift and go to state 42
    IF              shift and go to state 43
    WHILE           shift and go to state 44
    RETURN          shift and go to state 45
    RBRACE          reduce using rule 51 (empty -> .)

    statute                        shift and go to state 83
    assignation                    shift and go to state 36
    decision                       shift and go to state 37
    condition                      shift and go to state 38
    return                         shift and go to state 39
    function                       shift and go to state 40
    empty                          shift and go to state 41

state 63

    (18) parameters -> LPAREN type COLON id_list . RPAREN

    RPAREN          shift and go to state 84


state 64

    (47) factor -> ID .
    (15) function -> ID . LPAREN era_function expression RPAREN SEMICOLON

    TIMES           reduce using rule 47 (factor -> ID .)
    DIVIDE          reduce using rule 47 (factor -> ID .)
    SEMICOLON       reduce using rule 47 (factor -> ID .)
    PLUS            reduce using rule 47 (factor -> ID .)
    MINUS           reduce using rule 47 (factor -> ID .)
    GREATERTHAN     reduce using rule 47 (factor -> ID .)
    SMALLERTHAN     reduce using rule 47 (factor -> ID .)
    EQUALTO         reduce using rule 47 (factor -> ID .)
    RPAREN          reduce using rule 47 (factor -> ID .)
    LPAREN          shift and go to state 57


state 65

    (25) assignation -> ID EQUAL expression . SEMICOLON
    (37) expression -> expression . PLUS term
    (38) expression -> expression . MINUS term

    SEMICOLON       shift and go to state 85
    PLUS            shift and go to state 86
    MINUS           shift and go to state 87


state 66

    (48) factor -> PLUS . factor
    (43) factor -> . FLOAT
    (44) factor -> . INT
    (45) factor -> . STRING
    (46) factor -> . function
    (47) factor -> . ID
    (48) factor -> . PLUS factor
    (49) factor -> . MINUS factor
    (50) factor -> . LPAREN expression RPAREN
    (15) function -> . ID LPAREN era_function expression RPAREN SEMICOLON

    FLOAT           shift and go to state 70
    INT             shift and go to state 71
    STRING          shift and go to state 72
    ID              shift and go to state 64
    PLUS            shift and go to state 66
    MINUS           shift and go to state 68
    LPAREN          shift and go to state 74

    factor                         shift and go to state 88
    function                       shift and go to state 73

state 67

    (39) expression -> term .
    (40) term -> term . TIMES factor
    (41) term -> term . DIVIDE factor

    SEMICOLON       reduce using rule 39 (expression -> term .)
    PLUS            reduce using rule 39 (expression -> term .)
    MINUS           reduce using rule 39 (expression -> term .)
    GREATERTHAN     reduce using rule 39 (expression -> term .)
    SMALLERTHAN     reduce using rule 39 (expression -> term .)
    EQUALTO         reduce using rule 39 (expression -> term .)
    RPAREN          reduce using rule 39 (expression -> term .)
    TIMES           shift and go to state 89
    DIVIDE          shift and go to state 90


state 68

    (49) factor -> MINUS . factor
    (43) factor -> . FLOAT
    (44) factor -> . INT
    (45) factor -> . STRING
    (46) factor -> . function
    (47) factor -> . ID
    (48) factor -> . PLUS factor
    (49) factor -> . MINUS factor
    (50) factor -> . LPAREN expression RPAREN
    (15) function -> . ID LPAREN era_function expression RPAREN SEMICOLON

    FLOAT           shift and go to state 70
    INT             shift and go to state 71
    STRING          shift and go to state 72
    ID              shift and go to state 64
    PLUS            shift and go to state 66
    MINUS           shift and go to state 68
    LPAREN          shift and go to state 74

    factor                         shift and go to state 91
    function                       shift and go to state 73

state 69

    (42) term -> factor .

    TIMES           reduce using rule 42 (term -> factor .)
    DIVIDE          reduce using rule 42 (term -> factor .)
    SEMICOLON       reduce using rule 42 (term -> factor .)
    PLUS            reduce using rule 42 (term -> factor .)
    MINUS           reduce using rule 42 (term -> factor .)
    GREATERTHAN     reduce using rule 42 (term -> factor .)
    SMALLERTHAN     reduce using rule 42 (term -> factor .)
    EQUALTO         reduce using rule 42 (term -> factor .)
    RPAREN          reduce using rule 42 (term -> factor .)


state 70

    (43) factor -> FLOAT .

    TIMES           reduce using rule 43 (factor -> FLOAT .)
    DIVIDE          reduce using rule 43 (factor -> FLOAT .)
    SEMICOLON       reduce using rule 43 (factor -> FLOAT .)
    PLUS            reduce using rule 43 (factor -> FLOAT .)
    MINUS           reduce using rule 43 (factor -> FLOAT .)
    GREATERTHAN     reduce using rule 43 (factor -> FLOAT .)
    SMALLERTHAN     reduce using rule 43 (factor -> FLOAT .)
    EQUALTO         reduce using rule 43 (factor -> FLOAT .)
    RPAREN          reduce using rule 43 (factor -> FLOAT .)


state 71

    (44) factor -> INT .

    TIMES           reduce using rule 44 (factor -> INT .)
    DIVIDE          reduce using rule 44 (factor -> INT .)
    SEMICOLON       reduce using rule 44 (factor -> INT .)
    PLUS            reduce using rule 44 (factor -> INT .)
    MINUS           reduce using rule 44 (factor -> INT .)
    GREATERTHAN     reduce using rule 44 (factor -> INT .)
    SMALLERTHAN     reduce using rule 44 (factor -> INT .)
    EQUALTO         reduce using rule 44 (factor -> INT .)
    RPAREN          reduce using rule 44 (factor -> INT .)


state 72

    (45) factor -> STRING .

    TIMES           reduce using rule 45 (factor -> STRING .)
    DIVIDE          reduce using rule 45 (factor -> STRING .)
    SEMICOLON       reduce using rule 45 (factor -> STRING .)
    PLUS            reduce using rule 45 (factor -> STRING .)
    MINUS           reduce using rule 45 (factor -> STRING .)
    GREATERTHAN     reduce using rule 45 (factor -> STRING .)
    SMALLERTHAN     reduce using rule 45 (factor -> STRING .)
    EQUALTO         reduce using rule 45 (factor -> STRING .)
    RPAREN          reduce using rule 45 (factor -> STRING .)


state 73

    (46) factor -> function .

    TIMES           reduce using rule 46 (factor -> function .)
    DIVIDE          reduce using rule 46 (factor -> function .)
    SEMICOLON       reduce using rule 46 (factor -> function .)
    PLUS            reduce using rule 46 (factor -> function .)
    MINUS           reduce using rule 46 (factor -> function .)
    GREATERTHAN     reduce using rule 46 (factor -> function .)
    SMALLERTHAN     reduce using rule 46 (factor -> function .)
    EQUALTO         reduce using rule 46 (factor -> function .)
    RPAREN          reduce using rule 46 (factor -> function .)


state 74

    (50) factor -> LPAREN . expression RPAREN
    (37) expression -> . expression PLUS term
    (38) expression -> . expression MINUS term
    (39) expression -> . term
    (40) term -> . term TIMES factor
    (41) term -> . term DIVIDE factor
    (42) term -> . factor
    (43) factor -> . FLOAT
    (44) factor -> . INT
    (45) factor -> . STRING
    (46) factor -> . function
    (47) factor -> . ID
    (48) factor -> . PLUS factor
    (49) factor -> . MINUS factor
    (50) factor -> . LPAREN expression RPAREN
    (15) function -> . ID LPAREN era_function expression RPAREN SEMICOLON

    FLOAT           shift and go to state 70
    INT             shift and go to state 71
    STRING          shift and go to state 72
    ID              shift and go to state 64
    PLUS            shift and go to state 66
    MINUS           shift and go to state 68
    LPAREN          shift and go to state 74

    expression                     shift and go to state 92
    term                           shift and go to state 67
    factor                         shift and go to state 69
    function                       shift and go to state 73

state 75

    (15) function -> ID LPAREN era_function . expression RPAREN SEMICOLON
    (37) expression -> . expression PLUS term
    (38) expression -> . expression MINUS term
    (39) expression -> . term
    (40) term -> . term TIMES factor
    (41) term -> . term DIVIDE factor
    (42) term -> . factor
    (43) factor -> . FLOAT
    (44) factor -> . INT
    (45) factor -> . STRING
    (46) factor -> . function
    (47) factor -> . ID
    (48) factor -> . PLUS factor
    (49) factor -> . MINUS factor
    (50) factor -> . LPAREN expression RPAREN
    (15) function -> . ID LPAREN era_function expression RPAREN SEMICOLON

    FLOAT           shift and go to state 70
    INT             shift and go to state 71
    STRING          shift and go to state 72
    ID              shift and go to state 64
    PLUS            shift and go to state 66
    MINUS           shift and go to state 68
    LPAREN          shift and go to state 74

    expression                     shift and go to state 93
    term                           shift and go to state 67
    factor                         shift and go to state 69
    function                       shift and go to state 73

state 76

    (16) era_function -> empty .

    FLOAT           reduce using rule 16 (era_function -> empty .)
    INT             reduce using rule 16 (era_function -> empty .)
    STRING          reduce using rule 16 (era_function -> empty .)
    ID              reduce using rule 16 (era_function -> empty .)
    PLUS            reduce using rule 16 (era_function -> empty .)
    MINUS           reduce using rule 16 (era_function -> empty .)
    LPAREN          reduce using rule 16 (era_function -> empty .)


state 77

    (26) decision -> IF LPAREN expression_bool . RPAREN THEN LBRACE statute RBRACE ELSE LBRACE def_else statute RBRACE
    (27) decision -> IF LPAREN expression_bool . RPAREN THEN LBRACE statute RBRACE

    RPAREN          shift and go to state 94


state 78

    (30) expression_bool -> expression . GREATERTHAN term
    (31) expression_bool -> expression . SMALLERTHAN term
    (32) expression_bool -> expression . EQUALTO term
    (37) expression -> expression . PLUS term
    (38) expression -> expression . MINUS term

    GREATERTHAN     shift and go to state 95
    SMALLERTHAN     shift and go to state 96
    EQUALTO         shift and go to state 97
    PLUS            shift and go to state 86
    MINUS           shift and go to state 87


state 79

    (29) condition -> WHILE LPAREN expression_bool_while . RPAREN DO LBRACE statute RBRACE

    RPAREN          shift and go to state 98


state 80

    (33) expression_bool_while -> expression . GREATERTHAN term
    (34) expression_bool_while -> expression . SMALLERTHAN term
    (35) expression_bool_while -> expression . EQUALTO term
    (37) expression -> expression . PLUS term
    (38) expression -> expression . MINUS term

    GREATERTHAN     shift and go to state 99
    SMALLERTHAN     shift and go to state 100
    EQUALTO         shift and go to state 101
    PLUS            shift and go to state 86
    MINUS           shift and go to state 87


state 81

    (36) return -> RETURN LPAREN expression . RPAREN SEMICOLON
    (37) expression -> expression . PLUS term
    (38) expression -> expression . MINUS term

    RPAREN          shift and go to state 102
    PLUS            shift and go to state 86
    MINUS           shift and go to state 87


state 82

    (13) define_vars_function -> type COLON id_list . SEMICOLON define_vars_function

    SEMICOLON       shift and go to state 103


state 83

    (10) define_function -> FUNCTION type ID parameters VARS define_vars_function LBRACE statute . RBRACE endfunc define_function

    RBRACE          shift and go to state 104


state 84

    (18) parameters -> LPAREN type COLON id_list RPAREN .

    VARS            reduce using rule 18 (parameters -> LPAREN type COLON id_list RPAREN .)


state 85

    (25) assignation -> ID EQUAL expression SEMICOLON .

    ID              reduce using rule 25 (assignation -> ID EQUAL expression SEMICOLON .)
    IF              reduce using rule 25 (assignation -> ID EQUAL expression SEMICOLON .)
    WHILE           reduce using rule 25 (assignation -> ID EQUAL expression SEMICOLON .)
    RETURN          reduce using rule 25 (assignation -> ID EQUAL expression SEMICOLON .)
    RBRACE          reduce using rule 25 (assignation -> ID EQUAL expression SEMICOLON .)


state 86

    (37) expression -> expression PLUS . term
    (40) term -> . term TIMES factor
    (41) term -> . term DIVIDE factor
    (42) term -> . factor
    (43) factor -> . FLOAT
    (44) factor -> . INT
    (45) factor -> . STRING
    (46) factor -> . function
    (47) factor -> . ID
    (48) factor -> . PLUS factor
    (49) factor -> . MINUS factor
    (50) factor -> . LPAREN expression RPAREN
    (15) function -> . ID LPAREN era_function expression RPAREN SEMICOLON

    FLOAT           shift and go to state 70
    INT             shift and go to state 71
    STRING          shift and go to state 72
    ID              shift and go to state 64
    PLUS            shift and go to state 66
    MINUS           shift and go to state 68
    LPAREN          shift and go to state 74

    term                           shift and go to state 105
    factor                         shift and go to state 69
    function                       shift and go to state 73

state 87

    (38) expression -> expression MINUS . term
    (40) term -> . term TIMES factor
    (41) term -> . term DIVIDE factor
    (42) term -> . factor
    (43) factor -> . FLOAT
    (44) factor -> . INT
    (45) factor -> . STRING
    (46) factor -> . function
    (47) factor -> . ID
    (48) factor -> . PLUS factor
    (49) factor -> . MINUS factor
    (50) factor -> . LPAREN expression RPAREN
    (15) function -> . ID LPAREN era_function expression RPAREN SEMICOLON

    FLOAT           shift and go to state 70
    INT             shift and go to state 71
    STRING          shift and go to state 72
    ID              shift and go to state 64
    PLUS            shift and go to state 66
    MINUS           shift and go to state 68
    LPAREN          shift and go to state 74

    term                           shift and go to state 106
    factor                         shift and go to state 69
    function                       shift and go to state 73

state 88

    (48) factor -> PLUS factor .

    TIMES           reduce using rule 48 (factor -> PLUS factor .)
    DIVIDE          reduce using rule 48 (factor -> PLUS factor .)
    SEMICOLON       reduce using rule 48 (factor -> PLUS factor .)
    PLUS            reduce using rule 48 (factor -> PLUS factor .)
    MINUS           reduce using rule 48 (factor -> PLUS factor .)
    GREATERTHAN     reduce using rule 48 (factor -> PLUS factor .)
    SMALLERTHAN     reduce using rule 48 (factor -> PLUS factor .)
    EQUALTO         reduce using rule 48 (factor -> PLUS factor .)
    RPAREN          reduce using rule 48 (factor -> PLUS factor .)


state 89

    (40) term -> term TIMES . factor
    (43) factor -> . FLOAT
    (44) factor -> . INT
    (45) factor -> . STRING
    (46) factor -> . function
    (47) factor -> . ID
    (48) factor -> . PLUS factor
    (49) factor -> . MINUS factor
    (50) factor -> . LPAREN expression RPAREN
    (15) function -> . ID LPAREN era_function expression RPAREN SEMICOLON

    FLOAT           shift and go to state 70
    INT             shift and go to state 71
    STRING          shift and go to state 72
    ID              shift and go to state 64
    PLUS            shift and go to state 66
    MINUS           shift and go to state 68
    LPAREN          shift and go to state 74

    factor                         shift and go to state 107
    function                       shift and go to state 73

state 90

    (41) term -> term DIVIDE . factor
    (43) factor -> . FLOAT
    (44) factor -> . INT
    (45) factor -> . STRING
    (46) factor -> . function
    (47) factor -> . ID
    (48) factor -> . PLUS factor
    (49) factor -> . MINUS factor
    (50) factor -> . LPAREN expression RPAREN
    (15) function -> . ID LPAREN era_function expression RPAREN SEMICOLON

    FLOAT           shift and go to state 70
    INT             shift and go to state 71
    STRING          shift and go to state 72
    ID              shift and go to state 64
    PLUS            shift and go to state 66
    MINUS           shift and go to state 68
    LPAREN          shift and go to state 74

    factor                         shift and go to state 108
    function                       shift and go to state 73

state 91

    (49) factor -> MINUS factor .

    TIMES           reduce using rule 49 (factor -> MINUS factor .)
    DIVIDE          reduce using rule 49 (factor -> MINUS factor .)
    SEMICOLON       reduce using rule 49 (factor -> MINUS factor .)
    PLUS            reduce using rule 49 (factor -> MINUS factor .)
    MINUS           reduce using rule 49 (factor -> MINUS factor .)
    GREATERTHAN     reduce using rule 49 (factor -> MINUS factor .)
    SMALLERTHAN     reduce using rule 49 (factor -> MINUS factor .)
    EQUALTO         reduce using rule 49 (factor -> MINUS factor .)
    RPAREN          reduce using rule 49 (factor -> MINUS factor .)


state 92

    (50) factor -> LPAREN expression . RPAREN
    (37) expression -> expression . PLUS term
    (38) expression -> expression . MINUS term

    RPAREN          shift and go to state 109
    PLUS            shift and go to state 86
    MINUS           shift and go to state 87


state 93

    (15) function -> ID LPAREN era_function expression . RPAREN SEMICOLON
    (37) expression -> expression . PLUS term
    (38) expression -> expression . MINUS term

    RPAREN          shift and go to state 110
    PLUS            shift and go to state 86
    MINUS           shift and go to state 87


state 94

    (26) decision -> IF LPAREN expression_bool RPAREN . THEN LBRACE statute RBRACE ELSE LBRACE def_else statute RBRACE
    (27) decision -> IF LPAREN expression_bool RPAREN . THEN LBRACE statute RBRACE

    THEN            shift and go to state 111


state 95

    (30) expression_bool -> expression GREATERTHAN . term
    (40) term -> . term TIMES factor
    (41) term -> . term DIVIDE factor
    (42) term -> . factor
    (43) factor -> . FLOAT
    (44) factor -> . INT
    (45) factor -> . STRING
    (46) factor -> . function
    (47) factor -> . ID
    (48) factor -> . PLUS factor
    (49) factor -> . MINUS factor
    (50) factor -> . LPAREN expression RPAREN
    (15) function -> . ID LPAREN era_function expression RPAREN SEMICOLON

    FLOAT           shift and go to state 70
    INT             shift and go to state 71
    STRING          shift and go to state 72
    ID              shift and go to state 64
    PLUS            shift and go to state 66
    MINUS           shift and go to state 68
    LPAREN          shift and go to state 74

    term                           shift and go to state 112
    factor                         shift and go to state 69
    function                       shift and go to state 73

state 96

    (31) expression_bool -> expression SMALLERTHAN . term
    (40) term -> . term TIMES factor
    (41) term -> . term DIVIDE factor
    (42) term -> . factor
    (43) factor -> . FLOAT
    (44) factor -> . INT
    (45) factor -> . STRING
    (46) factor -> . function
    (47) factor -> . ID
    (48) factor -> . PLUS factor
    (49) factor -> . MINUS factor
    (50) factor -> . LPAREN expression RPAREN
    (15) function -> . ID LPAREN era_function expression RPAREN SEMICOLON

    FLOAT           shift and go to state 70
    INT             shift and go to state 71
    STRING          shift and go to state 72
    ID              shift and go to state 64
    PLUS            shift and go to state 66
    MINUS           shift and go to state 68
    LPAREN          shift and go to state 74

    term                           shift and go to state 113
    factor                         shift and go to state 69
    function                       shift and go to state 73

state 97

    (32) expression_bool -> expression EQUALTO . term
    (40) term -> . term TIMES factor
    (41) term -> . term DIVIDE factor
    (42) term -> . factor
    (43) factor -> . FLOAT
    (44) factor -> . INT
    (45) factor -> . STRING
    (46) factor -> . function
    (47) factor -> . ID
    (48) factor -> . PLUS factor
    (49) factor -> . MINUS factor
    (50) factor -> . LPAREN expression RPAREN
    (15) function -> . ID LPAREN era_function expression RPAREN SEMICOLON

    FLOAT           shift and go to state 70
    INT             shift and go to state 71
    STRING          shift and go to state 72
    ID              shift and go to state 64
    PLUS            shift and go to state 66
    MINUS           shift and go to state 68
    LPAREN          shift and go to state 74

    term                           shift and go to state 114
    factor                         shift and go to state 69
    function                       shift and go to state 73

state 98

    (29) condition -> WHILE LPAREN expression_bool_while RPAREN . DO LBRACE statute RBRACE

    DO              shift and go to state 115


state 99

    (33) expression_bool_while -> expression GREATERTHAN . term
    (40) term -> . term TIMES factor
    (41) term -> . term DIVIDE factor
    (42) term -> . factor
    (43) factor -> . FLOAT
    (44) factor -> . INT
    (45) factor -> . STRING
    (46) factor -> . function
    (47) factor -> . ID
    (48) factor -> . PLUS factor
    (49) factor -> . MINUS factor
    (50) factor -> . LPAREN expression RPAREN
    (15) function -> . ID LPAREN era_function expression RPAREN SEMICOLON

    FLOAT           shift and go to state 70
    INT             shift and go to state 71
    STRING          shift and go to state 72
    ID              shift and go to state 64
    PLUS            shift and go to state 66
    MINUS           shift and go to state 68
    LPAREN          shift and go to state 74

    term                           shift and go to state 116
    factor                         shift and go to state 69
    function                       shift and go to state 73

state 100

    (34) expression_bool_while -> expression SMALLERTHAN . term
    (40) term -> . term TIMES factor
    (41) term -> . term DIVIDE factor
    (42) term -> . factor
    (43) factor -> . FLOAT
    (44) factor -> . INT
    (45) factor -> . STRING
    (46) factor -> . function
    (47) factor -> . ID
    (48) factor -> . PLUS factor
    (49) factor -> . MINUS factor
    (50) factor -> . LPAREN expression RPAREN
    (15) function -> . ID LPAREN era_function expression RPAREN SEMICOLON

    FLOAT           shift and go to state 70
    INT             shift and go to state 71
    STRING          shift and go to state 72
    ID              shift and go to state 64
    PLUS            shift and go to state 66
    MINUS           shift and go to state 68
    LPAREN          shift and go to state 74

    term                           shift and go to state 117
    factor                         shift and go to state 69
    function                       shift and go to state 73

state 101

    (35) expression_bool_while -> expression EQUALTO . term
    (40) term -> . term TIMES factor
    (41) term -> . term DIVIDE factor
    (42) term -> . factor
    (43) factor -> . FLOAT
    (44) factor -> . INT
    (45) factor -> . STRING
    (46) factor -> . function
    (47) factor -> . ID
    (48) factor -> . PLUS factor
    (49) factor -> . MINUS factor
    (50) factor -> . LPAREN expression RPAREN
    (15) function -> . ID LPAREN era_function expression RPAREN SEMICOLON

    FLOAT           shift and go to state 70
    INT             shift and go to state 71
    STRING          shift and go to state 72
    ID              shift and go to state 64
    PLUS            shift and go to state 66
    MINUS           shift and go to state 68
    LPAREN          shift and go to state 74

    term                           shift and go to state 118
    factor                         shift and go to state 69
    function                       shift and go to state 73

state 102

    (36) return -> RETURN LPAREN expression RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 119


state 103

    (13) define_vars_function -> type COLON id_list SEMICOLON . define_vars_function
    (13) define_vars_function -> . type COLON id_list SEMICOLON define_vars_function
    (14) define_vars_function -> . empty
    (7) type -> . INT
    (8) type -> . FLOAT
    (9) type -> . STRING
    (51) empty -> .

    INT             shift and go to state 11
    FLOAT           shift and go to state 12
    STRING          shift and go to state 13
    LBRACE          reduce using rule 51 (empty -> .)

    type                           shift and go to state 46
    define_vars_function           shift and go to state 120
    empty                          shift and go to state 48

state 104

    (10) define_function -> FUNCTION type ID parameters VARS define_vars_function LBRACE statute RBRACE . endfunc define_function
    (12) endfunc -> . empty
    (51) empty -> .

    FUNCTION        reduce using rule 51 (empty -> .)
    MAIN            reduce using rule 51 (empty -> .)

    endfunc                        shift and go to state 121
    empty                          shift and go to state 122

state 105

    (37) expression -> expression PLUS term .
    (40) term -> term . TIMES factor
    (41) term -> term . DIVIDE factor

    SEMICOLON       reduce using rule 37 (expression -> expression PLUS term .)
    PLUS            reduce using rule 37 (expression -> expression PLUS term .)
    MINUS           reduce using rule 37 (expression -> expression PLUS term .)
    GREATERTHAN     reduce using rule 37 (expression -> expression PLUS term .)
    SMALLERTHAN     reduce using rule 37 (expression -> expression PLUS term .)
    EQUALTO         reduce using rule 37 (expression -> expression PLUS term .)
    RPAREN          reduce using rule 37 (expression -> expression PLUS term .)
    TIMES           shift and go to state 89
    DIVIDE          shift and go to state 90


state 106

    (38) expression -> expression MINUS term .
    (40) term -> term . TIMES factor
    (41) term -> term . DIVIDE factor

    SEMICOLON       reduce using rule 38 (expression -> expression MINUS term .)
    PLUS            reduce using rule 38 (expression -> expression MINUS term .)
    MINUS           reduce using rule 38 (expression -> expression MINUS term .)
    GREATERTHAN     reduce using rule 38 (expression -> expression MINUS term .)
    SMALLERTHAN     reduce using rule 38 (expression -> expression MINUS term .)
    EQUALTO         reduce using rule 38 (expression -> expression MINUS term .)
    RPAREN          reduce using rule 38 (expression -> expression MINUS term .)
    TIMES           shift and go to state 89
    DIVIDE          shift and go to state 90


state 107

    (40) term -> term TIMES factor .

    TIMES           reduce using rule 40 (term -> term TIMES factor .)
    DIVIDE          reduce using rule 40 (term -> term TIMES factor .)
    SEMICOLON       reduce using rule 40 (term -> term TIMES factor .)
    PLUS            reduce using rule 40 (term -> term TIMES factor .)
    MINUS           reduce using rule 40 (term -> term TIMES factor .)
    GREATERTHAN     reduce using rule 40 (term -> term TIMES factor .)
    SMALLERTHAN     reduce using rule 40 (term -> term TIMES factor .)
    EQUALTO         reduce using rule 40 (term -> term TIMES factor .)
    RPAREN          reduce using rule 40 (term -> term TIMES factor .)


state 108

    (41) term -> term DIVIDE factor .

    TIMES           reduce using rule 41 (term -> term DIVIDE factor .)
    DIVIDE          reduce using rule 41 (term -> term DIVIDE factor .)
    SEMICOLON       reduce using rule 41 (term -> term DIVIDE factor .)
    PLUS            reduce using rule 41 (term -> term DIVIDE factor .)
    MINUS           reduce using rule 41 (term -> term DIVIDE factor .)
    GREATERTHAN     reduce using rule 41 (term -> term DIVIDE factor .)
    SMALLERTHAN     reduce using rule 41 (term -> term DIVIDE factor .)
    EQUALTO         reduce using rule 41 (term -> term DIVIDE factor .)
    RPAREN          reduce using rule 41 (term -> term DIVIDE factor .)


state 109

    (50) factor -> LPAREN expression RPAREN .

    TIMES           reduce using rule 50 (factor -> LPAREN expression RPAREN .)
    DIVIDE          reduce using rule 50 (factor -> LPAREN expression RPAREN .)
    SEMICOLON       reduce using rule 50 (factor -> LPAREN expression RPAREN .)
    PLUS            reduce using rule 50 (factor -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 50 (factor -> LPAREN expression RPAREN .)
    GREATERTHAN     reduce using rule 50 (factor -> LPAREN expression RPAREN .)
    SMALLERTHAN     reduce using rule 50 (factor -> LPAREN expression RPAREN .)
    EQUALTO         reduce using rule 50 (factor -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 50 (factor -> LPAREN expression RPAREN .)


state 110

    (15) function -> ID LPAREN era_function expression RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 123


state 111

    (26) decision -> IF LPAREN expression_bool RPAREN THEN . LBRACE statute RBRACE ELSE LBRACE def_else statute RBRACE
    (27) decision -> IF LPAREN expression_bool RPAREN THEN . LBRACE statute RBRACE

    LBRACE          shift and go to state 124


state 112

    (30) expression_bool -> expression GREATERTHAN term .
    (40) term -> term . TIMES factor
    (41) term -> term . DIVIDE factor

    RPAREN          reduce using rule 30 (expression_bool -> expression GREATERTHAN term .)
    TIMES           shift and go to state 89
    DIVIDE          shift and go to state 90


state 113

    (31) expression_bool -> expression SMALLERTHAN term .
    (40) term -> term . TIMES factor
    (41) term -> term . DIVIDE factor

    RPAREN          reduce using rule 31 (expression_bool -> expression SMALLERTHAN term .)
    TIMES           shift and go to state 89
    DIVIDE          shift and go to state 90


state 114

    (32) expression_bool -> expression EQUALTO term .
    (40) term -> term . TIMES factor
    (41) term -> term . DIVIDE factor

    RPAREN          reduce using rule 32 (expression_bool -> expression EQUALTO term .)
    TIMES           shift and go to state 89
    DIVIDE          shift and go to state 90


state 115

    (29) condition -> WHILE LPAREN expression_bool_while RPAREN DO . LBRACE statute RBRACE

    LBRACE          shift and go to state 125


state 116

    (33) expression_bool_while -> expression GREATERTHAN term .
    (40) term -> term . TIMES factor
    (41) term -> term . DIVIDE factor

    RPAREN          reduce using rule 33 (expression_bool_while -> expression GREATERTHAN term .)
    TIMES           shift and go to state 89
    DIVIDE          shift and go to state 90


state 117

    (34) expression_bool_while -> expression SMALLERTHAN term .
    (40) term -> term . TIMES factor
    (41) term -> term . DIVIDE factor

    RPAREN          reduce using rule 34 (expression_bool_while -> expression SMALLERTHAN term .)
    TIMES           shift and go to state 89
    DIVIDE          shift and go to state 90


state 118

    (35) expression_bool_while -> expression EQUALTO term .
    (40) term -> term . TIMES factor
    (41) term -> term . DIVIDE factor

    RPAREN          reduce using rule 35 (expression_bool_while -> expression EQUALTO term .)
    TIMES           shift and go to state 89
    DIVIDE          shift and go to state 90


state 119

    (36) return -> RETURN LPAREN expression RPAREN SEMICOLON .

    ID              reduce using rule 36 (return -> RETURN LPAREN expression RPAREN SEMICOLON .)
    IF              reduce using rule 36 (return -> RETURN LPAREN expression RPAREN SEMICOLON .)
    WHILE           reduce using rule 36 (return -> RETURN LPAREN expression RPAREN SEMICOLON .)
    RETURN          reduce using rule 36 (return -> RETURN LPAREN expression RPAREN SEMICOLON .)
    RBRACE          reduce using rule 36 (return -> RETURN LPAREN expression RPAREN SEMICOLON .)


state 120

    (13) define_vars_function -> type COLON id_list SEMICOLON define_vars_function .

    LBRACE          reduce using rule 13 (define_vars_function -> type COLON id_list SEMICOLON define_vars_function .)


state 121

    (10) define_function -> FUNCTION type ID parameters VARS define_vars_function LBRACE statute RBRACE endfunc . define_function
    (10) define_function -> . FUNCTION type ID parameters VARS define_vars_function LBRACE statute RBRACE endfunc define_function
    (11) define_function -> . empty
    (51) empty -> .

    FUNCTION        shift and go to state 15
    MAIN            reduce using rule 51 (empty -> .)

    define_function                shift and go to state 126
    empty                          shift and go to state 16

state 122

    (12) endfunc -> empty .

    FUNCTION        reduce using rule 12 (endfunc -> empty .)
    MAIN            reduce using rule 12 (endfunc -> empty .)


state 123

    (15) function -> ID LPAREN era_function expression RPAREN SEMICOLON .

    ID              reduce using rule 15 (function -> ID LPAREN era_function expression RPAREN SEMICOLON .)
    IF              reduce using rule 15 (function -> ID LPAREN era_function expression RPAREN SEMICOLON .)
    WHILE           reduce using rule 15 (function -> ID LPAREN era_function expression RPAREN SEMICOLON .)
    RETURN          reduce using rule 15 (function -> ID LPAREN era_function expression RPAREN SEMICOLON .)
    RBRACE          reduce using rule 15 (function -> ID LPAREN era_function expression RPAREN SEMICOLON .)
    TIMES           reduce using rule 15 (function -> ID LPAREN era_function expression RPAREN SEMICOLON .)
    DIVIDE          reduce using rule 15 (function -> ID LPAREN era_function expression RPAREN SEMICOLON .)
    SEMICOLON       reduce using rule 15 (function -> ID LPAREN era_function expression RPAREN SEMICOLON .)
    PLUS            reduce using rule 15 (function -> ID LPAREN era_function expression RPAREN SEMICOLON .)
    MINUS           reduce using rule 15 (function -> ID LPAREN era_function expression RPAREN SEMICOLON .)
    GREATERTHAN     reduce using rule 15 (function -> ID LPAREN era_function expression RPAREN SEMICOLON .)
    SMALLERTHAN     reduce using rule 15 (function -> ID LPAREN era_function expression RPAREN SEMICOLON .)
    EQUALTO         reduce using rule 15 (function -> ID LPAREN era_function expression RPAREN SEMICOLON .)
    RPAREN          reduce using rule 15 (function -> ID LPAREN era_function expression RPAREN SEMICOLON .)


state 124

    (26) decision -> IF LPAREN expression_bool RPAREN THEN LBRACE . statute RBRACE ELSE LBRACE def_else statute RBRACE
    (27) decision -> IF LPAREN expression_bool RPAREN THEN LBRACE . statute RBRACE
    (19) statute -> . assignation statute
    (20) statute -> . decision statute
    (21) statute -> . condition statute
    (22) statute -> . return statute
    (23) statute -> . function statute
    (24) statute -> . empty
    (25) assignation -> . ID EQUAL expression SEMICOLON
    (26) decision -> . IF LPAREN expression_bool RPAREN THEN LBRACE statute RBRACE ELSE LBRACE def_else statute RBRACE
    (27) decision -> . IF LPAREN expression_bool RPAREN THEN LBRACE statute RBRACE
    (29) condition -> . WHILE LPAREN expression_bool_while RPAREN DO LBRACE statute RBRACE
    (36) return -> . RETURN LPAREN expression RPAREN SEMICOLON
    (15) function -> . ID LPAREN era_function expression RPAREN SEMICOLON
    (51) empty -> .

    ID              shift and go to state 42
    IF              shift and go to state 43
    WHILE           shift and go to state 44
    RETURN          shift and go to state 45
    RBRACE          reduce using rule 51 (empty -> .)

    statute                        shift and go to state 127
    assignation                    shift and go to state 36
    decision                       shift and go to state 37
    condition                      shift and go to state 38
    return                         shift and go to state 39
    function                       shift and go to state 40
    empty                          shift and go to state 41

state 125

    (29) condition -> WHILE LPAREN expression_bool_while RPAREN DO LBRACE . statute RBRACE
    (19) statute -> . assignation statute
    (20) statute -> . decision statute
    (21) statute -> . condition statute
    (22) statute -> . return statute
    (23) statute -> . function statute
    (24) statute -> . empty
    (25) assignation -> . ID EQUAL expression SEMICOLON
    (26) decision -> . IF LPAREN expression_bool RPAREN THEN LBRACE statute RBRACE ELSE LBRACE def_else statute RBRACE
    (27) decision -> . IF LPAREN expression_bool RPAREN THEN LBRACE statute RBRACE
    (29) condition -> . WHILE LPAREN expression_bool_while RPAREN DO LBRACE statute RBRACE
    (36) return -> . RETURN LPAREN expression RPAREN SEMICOLON
    (15) function -> . ID LPAREN era_function expression RPAREN SEMICOLON
    (51) empty -> .

    ID              shift and go to state 42
    IF              shift and go to state 43
    WHILE           shift and go to state 44
    RETURN          shift and go to state 45
    RBRACE          reduce using rule 51 (empty -> .)

    statute                        shift and go to state 128
    assignation                    shift and go to state 36
    decision                       shift and go to state 37
    condition                      shift and go to state 38
    return                         shift and go to state 39
    function                       shift and go to state 40
    empty                          shift and go to state 41

state 126

    (10) define_function -> FUNCTION type ID parameters VARS define_vars_function LBRACE statute RBRACE endfunc define_function .

    MAIN            reduce using rule 10 (define_function -> FUNCTION type ID parameters VARS define_vars_function LBRACE statute RBRACE endfunc define_function .)


state 127

    (26) decision -> IF LPAREN expression_bool RPAREN THEN LBRACE statute . RBRACE ELSE LBRACE def_else statute RBRACE
    (27) decision -> IF LPAREN expression_bool RPAREN THEN LBRACE statute . RBRACE

    RBRACE          shift and go to state 129


state 128

    (29) condition -> WHILE LPAREN expression_bool_while RPAREN DO LBRACE statute . RBRACE

    RBRACE          shift and go to state 130


state 129

    (26) decision -> IF LPAREN expression_bool RPAREN THEN LBRACE statute RBRACE . ELSE LBRACE def_else statute RBRACE
    (27) decision -> IF LPAREN expression_bool RPAREN THEN LBRACE statute RBRACE .

    ELSE            shift and go to state 131
    ID              reduce using rule 27 (decision -> IF LPAREN expression_bool RPAREN THEN LBRACE statute RBRACE .)
    IF              reduce using rule 27 (decision -> IF LPAREN expression_bool RPAREN THEN LBRACE statute RBRACE .)
    WHILE           reduce using rule 27 (decision -> IF LPAREN expression_bool RPAREN THEN LBRACE statute RBRACE .)
    RETURN          reduce using rule 27 (decision -> IF LPAREN expression_bool RPAREN THEN LBRACE statute RBRACE .)
    RBRACE          reduce using rule 27 (decision -> IF LPAREN expression_bool RPAREN THEN LBRACE statute RBRACE .)


state 130

    (29) condition -> WHILE LPAREN expression_bool_while RPAREN DO LBRACE statute RBRACE .

    ID              reduce using rule 29 (condition -> WHILE LPAREN expression_bool_while RPAREN DO LBRACE statute RBRACE .)
    IF              reduce using rule 29 (condition -> WHILE LPAREN expression_bool_while RPAREN DO LBRACE statute RBRACE .)
    WHILE           reduce using rule 29 (condition -> WHILE LPAREN expression_bool_while RPAREN DO LBRACE statute RBRACE .)
    RETURN          reduce using rule 29 (condition -> WHILE LPAREN expression_bool_while RPAREN DO LBRACE statute RBRACE .)
    RBRACE          reduce using rule 29 (condition -> WHILE LPAREN expression_bool_while RPAREN DO LBRACE statute RBRACE .)


state 131

    (26) decision -> IF LPAREN expression_bool RPAREN THEN LBRACE statute RBRACE ELSE . LBRACE def_else statute RBRACE

    LBRACE          shift and go to state 132


state 132

    (26) decision -> IF LPAREN expression_bool RPAREN THEN LBRACE statute RBRACE ELSE LBRACE . def_else statute RBRACE
    (28) def_else -> . empty
    (51) empty -> .

    ID              reduce using rule 51 (empty -> .)
    IF              reduce using rule 51 (empty -> .)
    WHILE           reduce using rule 51 (empty -> .)
    RETURN          reduce using rule 51 (empty -> .)
    RBRACE          reduce using rule 51 (empty -> .)

    def_else                       shift and go to state 133
    empty                          shift and go to state 134

state 133

    (26) decision -> IF LPAREN expression_bool RPAREN THEN LBRACE statute RBRACE ELSE LBRACE def_else . statute RBRACE
    (19) statute -> . assignation statute
    (20) statute -> . decision statute
    (21) statute -> . condition statute
    (22) statute -> . return statute
    (23) statute -> . function statute
    (24) statute -> . empty
    (25) assignation -> . ID EQUAL expression SEMICOLON
    (26) decision -> . IF LPAREN expression_bool RPAREN THEN LBRACE statute RBRACE ELSE LBRACE def_else statute RBRACE
    (27) decision -> . IF LPAREN expression_bool RPAREN THEN LBRACE statute RBRACE
    (29) condition -> . WHILE LPAREN expression_bool_while RPAREN DO LBRACE statute RBRACE
    (36) return -> . RETURN LPAREN expression RPAREN SEMICOLON
    (15) function -> . ID LPAREN era_function expression RPAREN SEMICOLON
    (51) empty -> .

    ID              shift and go to state 42
    IF              shift and go to state 43
    WHILE           shift and go to state 44
    RETURN          shift and go to state 45
    RBRACE          reduce using rule 51 (empty -> .)

    statute                        shift and go to state 135
    assignation                    shift and go to state 36
    decision                       shift and go to state 37
    condition                      shift and go to state 38
    return                         shift and go to state 39
    function                       shift and go to state 40
    empty                          shift and go to state 41

state 134

    (28) def_else -> empty .

    ID              reduce using rule 28 (def_else -> empty .)
    IF              reduce using rule 28 (def_else -> empty .)
    WHILE           reduce using rule 28 (def_else -> empty .)
    RETURN          reduce using rule 28 (def_else -> empty .)
    RBRACE          reduce using rule 28 (def_else -> empty .)


state 135

    (26) decision -> IF LPAREN expression_bool RPAREN THEN LBRACE statute RBRACE ELSE LBRACE def_else statute . RBRACE

    RBRACE          shift and go to state 136


state 136

    (26) decision -> IF LPAREN expression_bool RPAREN THEN LBRACE statute RBRACE ELSE LBRACE def_else statute RBRACE .

    ID              reduce using rule 26 (decision -> IF LPAREN expression_bool RPAREN THEN LBRACE statute RBRACE ELSE LBRACE def_else statute RBRACE .)
    IF              reduce using rule 26 (decision -> IF LPAREN expression_bool RPAREN THEN LBRACE statute RBRACE ELSE LBRACE def_else statute RBRACE .)
    WHILE           reduce using rule 26 (decision -> IF LPAREN expression_bool RPAREN THEN LBRACE statute RBRACE ELSE LBRACE def_else statute RBRACE .)
    RETURN          reduce using rule 26 (decision -> IF LPAREN expression_bool RPAREN THEN LBRACE statute RBRACE ELSE LBRACE def_else statute RBRACE .)
    RBRACE          reduce using rule 26 (decision -> IF LPAREN expression_bool RPAREN THEN LBRACE statute RBRACE ELSE LBRACE def_else statute RBRACE .)

