Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    BOOL
    ENDL
    FALSE
    OR
    TRUE

Grammar

Rule 0     S' -> program
Rule 1     program -> goto_main PROGRAM ID SEMICOLON VARS define_vars_global define_function main
Rule 2     goto_main -> empty
Rule 3     id_list -> id_or_array COMMA id_list
Rule 4     id_list -> id_or_array
Rule 5     id_or_array -> ID
Rule 6     id_or_array -> array
Rule 7     array -> ID LBRACKET INT RBRACKET
Rule 8     define_vars_global -> type COLON id_list SEMICOLON define_vars_global
Rule 9     define_vars_global -> empty
Rule 10    type -> INT
Rule 11    type -> FLOAT
Rule 12    type -> STRING
Rule 13    define_function -> FUNCTION start_func type ID parameters VARS define_vars_function LBRACE statute RBRACE end_func define_function
Rule 14    define_function -> empty
Rule 15    start_func -> empty
Rule 16    end_func -> empty
Rule 17    define_vars_function -> type COLON id_list SEMICOLON define_vars_function
Rule 18    define_vars_function -> empty
Rule 19    function -> ID LPAREN era_function expression RPAREN
Rule 20    era_function -> empty
Rule 21    main -> MAIN LPAREN RPAREN LBRACE statute RBRACE
Rule 22    parameters -> LPAREN type COLON id_list RPAREN
Rule 23    statute -> assignation statute
Rule 24    statute -> decision statute
Rule 25    statute -> condition statute
Rule 26    statute -> return statute
Rule 27    statute -> function statute
Rule 28    statute -> write statute
Rule 29    statute -> read statute
Rule 30    statute -> empty
Rule 31    access_array -> ID LBRACKET INT RBRACKET
Rule 32    assignation -> ID EQUAL expression SEMICOLON
Rule 33    assignation -> access_array EQUAL expression SEMICOLON
Rule 34    decision -> IF LPAREN expression_bool RPAREN THEN LBRACE statute RBRACE ELSE LBRACE def_else statute RBRACE
Rule 35    decision -> IF LPAREN expression_bool RPAREN THEN LBRACE statute RBRACE
Rule 36    def_else -> empty
Rule 37    condition -> WHILE LPAREN expression_bool_while RPAREN DO LBRACE statute RBRACE
Rule 38    write -> WRITE LPAREN expression RPAREN
Rule 39    read -> READ LPAREN expression RPAREN
Rule 40    expression_bool -> expression GREATERTHAN term
Rule 41    expression_bool -> expression SMALLERTHAN term
Rule 42    expression_bool -> expression EQUALTO term
Rule 43    expression_bool_while -> expression GREATERTHAN term
Rule 44    expression_bool_while -> expression SMALLERTHAN term
Rule 45    expression_bool_while -> expression EQUALTO term
Rule 46    return -> RETURN LPAREN expression RPAREN
Rule 47    expression -> expression PLUS term
Rule 48    expression -> expression MINUS term
Rule 49    expression -> term
Rule 50    term -> term TIMES factor
Rule 51    term -> term DIVIDE factor
Rule 52    term -> factor
Rule 53    factor -> FLOAT
Rule 54    factor -> INT
Rule 55    factor -> STRING
Rule 56    factor -> function
Rule 57    factor -> access_array
Rule 58    factor -> ID
Rule 59    factor -> PLUS factor
Rule 60    factor -> MINUS factor
Rule 61    factor -> LPAREN expression RPAREN
Rule 62    empty -> <empty>

Terminals, with rules where they appear

BOOL                 : 
COLON                : 8 17 22
COMMA                : 3
DIVIDE               : 51
DO                   : 37
ELSE                 : 34
ENDL                 : 
EQUAL                : 32 33
EQUALTO              : 42 45
FALSE                : 
FLOAT                : 11 53
FUNCTION             : 13
GREATERTHAN          : 40 43
ID                   : 1 5 7 13 19 31 32 58
IF                   : 34 35
INT                  : 7 10 31 54
LBRACE               : 13 21 34 34 35 37
LBRACKET             : 7 31
LPAREN               : 19 21 22 34 35 37 38 39 46 61
MAIN                 : 21
MINUS                : 48 60
OR                   : 
PLUS                 : 47 59
PROGRAM              : 1
RBRACE               : 13 21 34 34 35 37
RBRACKET             : 7 31
READ                 : 39
RETURN               : 46
RPAREN               : 19 21 22 34 35 37 38 39 46 61
SEMICOLON            : 1 8 17 32 33
SMALLERTHAN          : 41 44
STRING               : 12 55
THEN                 : 34 35
TIMES                : 50
TRUE                 : 
VARS                 : 1 13
WHILE                : 37
WRITE                : 38
error                : 

Nonterminals, with rules where they appear

access_array         : 33 57
array                : 6
assignation          : 23
condition            : 25
decision             : 24
def_else             : 34
define_function      : 1 13
define_vars_function : 13 17
define_vars_global   : 1 8
empty                : 2 9 14 15 16 18 20 30 36
end_func             : 13
era_function         : 19
expression           : 19 32 33 38 39 40 41 42 43 44 45 46 47 48 61
expression_bool      : 34 35
expression_bool_while : 37
factor               : 50 51 52 59 60
function             : 27 56
goto_main            : 1
id_list              : 3 8 17 22
id_or_array          : 3 4
main                 : 1
parameters           : 13
program              : 0
read                 : 29
return               : 26
start_func           : 13
statute              : 13 21 23 24 25 26 27 28 29 34 34 35 37
term                 : 40 41 42 43 44 45 47 48 49 50 51
type                 : 8 13 17 22
write                : 28

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . goto_main PROGRAM ID SEMICOLON VARS define_vars_global define_function main
    (2) goto_main -> . empty
    (62) empty -> .

    PROGRAM         reduce using rule 62 (empty -> .)

    program                        shift and go to state 1
    goto_main                      shift and go to state 2
    empty                          shift and go to state 3

state 1

    (0) S' -> program .



state 2

    (1) program -> goto_main . PROGRAM ID SEMICOLON VARS define_vars_global define_function main

    PROGRAM         shift and go to state 4


state 3

    (2) goto_main -> empty .

    PROGRAM         reduce using rule 2 (goto_main -> empty .)


state 4

    (1) program -> goto_main PROGRAM . ID SEMICOLON VARS define_vars_global define_function main

    ID              shift and go to state 5


state 5

    (1) program -> goto_main PROGRAM ID . SEMICOLON VARS define_vars_global define_function main

    SEMICOLON       shift and go to state 6


state 6

    (1) program -> goto_main PROGRAM ID SEMICOLON . VARS define_vars_global define_function main

    VARS            shift and go to state 7


state 7

    (1) program -> goto_main PROGRAM ID SEMICOLON VARS . define_vars_global define_function main
    (8) define_vars_global -> . type COLON id_list SEMICOLON define_vars_global
    (9) define_vars_global -> . empty
    (10) type -> . INT
    (11) type -> . FLOAT
    (12) type -> . STRING
    (62) empty -> .

    INT             shift and go to state 11
    FLOAT           shift and go to state 12
    STRING          shift and go to state 13
    FUNCTION        reduce using rule 62 (empty -> .)
    MAIN            reduce using rule 62 (empty -> .)

    define_vars_global             shift and go to state 8
    type                           shift and go to state 9
    empty                          shift and go to state 10

state 8

    (1) program -> goto_main PROGRAM ID SEMICOLON VARS define_vars_global . define_function main
    (13) define_function -> . FUNCTION start_func type ID parameters VARS define_vars_function LBRACE statute RBRACE end_func define_function
    (14) define_function -> . empty
    (62) empty -> .

    FUNCTION        shift and go to state 15
    MAIN            reduce using rule 62 (empty -> .)

    define_function                shift and go to state 14
    empty                          shift and go to state 16

state 9

    (8) define_vars_global -> type . COLON id_list SEMICOLON define_vars_global

    COLON           shift and go to state 17


state 10

    (9) define_vars_global -> empty .

    FUNCTION        reduce using rule 9 (define_vars_global -> empty .)
    MAIN            reduce using rule 9 (define_vars_global -> empty .)


state 11

    (10) type -> INT .

    COLON           reduce using rule 10 (type -> INT .)
    ID              reduce using rule 10 (type -> INT .)


state 12

    (11) type -> FLOAT .

    COLON           reduce using rule 11 (type -> FLOAT .)
    ID              reduce using rule 11 (type -> FLOAT .)


state 13

    (12) type -> STRING .

    COLON           reduce using rule 12 (type -> STRING .)
    ID              reduce using rule 12 (type -> STRING .)


state 14

    (1) program -> goto_main PROGRAM ID SEMICOLON VARS define_vars_global define_function . main
    (21) main -> . MAIN LPAREN RPAREN LBRACE statute RBRACE

    MAIN            shift and go to state 19

    main                           shift and go to state 18

state 15

    (13) define_function -> FUNCTION . start_func type ID parameters VARS define_vars_function LBRACE statute RBRACE end_func define_function
    (15) start_func -> . empty
    (62) empty -> .

    INT             reduce using rule 62 (empty -> .)
    FLOAT           reduce using rule 62 (empty -> .)
    STRING          reduce using rule 62 (empty -> .)

    start_func                     shift and go to state 20
    empty                          shift and go to state 21

state 16

    (14) define_function -> empty .

    MAIN            reduce using rule 14 (define_function -> empty .)


state 17

    (8) define_vars_global -> type COLON . id_list SEMICOLON define_vars_global
    (3) id_list -> . id_or_array COMMA id_list
    (4) id_list -> . id_or_array
    (5) id_or_array -> . ID
    (6) id_or_array -> . array
    (7) array -> . ID LBRACKET INT RBRACKET

    ID              shift and go to state 24

    id_list                        shift and go to state 22
    id_or_array                    shift and go to state 23
    array                          shift and go to state 25

state 18

    (1) program -> goto_main PROGRAM ID SEMICOLON VARS define_vars_global define_function main .

    $end            reduce using rule 1 (program -> goto_main PROGRAM ID SEMICOLON VARS define_vars_global define_function main .)


state 19

    (21) main -> MAIN . LPAREN RPAREN LBRACE statute RBRACE

    LPAREN          shift and go to state 26


state 20

    (13) define_function -> FUNCTION start_func . type ID parameters VARS define_vars_function LBRACE statute RBRACE end_func define_function
    (10) type -> . INT
    (11) type -> . FLOAT
    (12) type -> . STRING

    INT             shift and go to state 11
    FLOAT           shift and go to state 12
    STRING          shift and go to state 13

    type                           shift and go to state 27

state 21

    (15) start_func -> empty .

    INT             reduce using rule 15 (start_func -> empty .)
    FLOAT           reduce using rule 15 (start_func -> empty .)
    STRING          reduce using rule 15 (start_func -> empty .)


state 22

    (8) define_vars_global -> type COLON id_list . SEMICOLON define_vars_global

    SEMICOLON       shift and go to state 28


state 23

    (3) id_list -> id_or_array . COMMA id_list
    (4) id_list -> id_or_array .

    COMMA           shift and go to state 29
    SEMICOLON       reduce using rule 4 (id_list -> id_or_array .)
    RPAREN          reduce using rule 4 (id_list -> id_or_array .)


state 24

    (5) id_or_array -> ID .
    (7) array -> ID . LBRACKET INT RBRACKET

    COMMA           reduce using rule 5 (id_or_array -> ID .)
    SEMICOLON       reduce using rule 5 (id_or_array -> ID .)
    RPAREN          reduce using rule 5 (id_or_array -> ID .)
    LBRACKET        shift and go to state 30


state 25

    (6) id_or_array -> array .

    COMMA           reduce using rule 6 (id_or_array -> array .)
    SEMICOLON       reduce using rule 6 (id_or_array -> array .)
    RPAREN          reduce using rule 6 (id_or_array -> array .)


state 26

    (21) main -> MAIN LPAREN . RPAREN LBRACE statute RBRACE

    RPAREN          shift and go to state 31


state 27

    (13) define_function -> FUNCTION start_func type . ID parameters VARS define_vars_function LBRACE statute RBRACE end_func define_function

    ID              shift and go to state 32


state 28

    (8) define_vars_global -> type COLON id_list SEMICOLON . define_vars_global
    (8) define_vars_global -> . type COLON id_list SEMICOLON define_vars_global
    (9) define_vars_global -> . empty
    (10) type -> . INT
    (11) type -> . FLOAT
    (12) type -> . STRING
    (62) empty -> .

    INT             shift and go to state 11
    FLOAT           shift and go to state 12
    STRING          shift and go to state 13
    FUNCTION        reduce using rule 62 (empty -> .)
    MAIN            reduce using rule 62 (empty -> .)

    type                           shift and go to state 9
    define_vars_global             shift and go to state 33
    empty                          shift and go to state 10

state 29

    (3) id_list -> id_or_array COMMA . id_list
    (3) id_list -> . id_or_array COMMA id_list
    (4) id_list -> . id_or_array
    (5) id_or_array -> . ID
    (6) id_or_array -> . array
    (7) array -> . ID LBRACKET INT RBRACKET

    ID              shift and go to state 24

    id_or_array                    shift and go to state 23
    id_list                        shift and go to state 34
    array                          shift and go to state 25

state 30

    (7) array -> ID LBRACKET . INT RBRACKET

    INT             shift and go to state 35


state 31

    (21) main -> MAIN LPAREN RPAREN . LBRACE statute RBRACE

    LBRACE          shift and go to state 36


state 32

    (13) define_function -> FUNCTION start_func type ID . parameters VARS define_vars_function LBRACE statute RBRACE end_func define_function
    (22) parameters -> . LPAREN type COLON id_list RPAREN

    LPAREN          shift and go to state 38

    parameters                     shift and go to state 37

state 33

    (8) define_vars_global -> type COLON id_list SEMICOLON define_vars_global .

    FUNCTION        reduce using rule 8 (define_vars_global -> type COLON id_list SEMICOLON define_vars_global .)
    MAIN            reduce using rule 8 (define_vars_global -> type COLON id_list SEMICOLON define_vars_global .)


state 34

    (3) id_list -> id_or_array COMMA id_list .

    SEMICOLON       reduce using rule 3 (id_list -> id_or_array COMMA id_list .)
    RPAREN          reduce using rule 3 (id_list -> id_or_array COMMA id_list .)


state 35

    (7) array -> ID LBRACKET INT . RBRACKET

    RBRACKET        shift and go to state 39


state 36

    (21) main -> MAIN LPAREN RPAREN LBRACE . statute RBRACE
    (23) statute -> . assignation statute
    (24) statute -> . decision statute
    (25) statute -> . condition statute
    (26) statute -> . return statute
    (27) statute -> . function statute
    (28) statute -> . write statute
    (29) statute -> . read statute
    (30) statute -> . empty
    (32) assignation -> . ID EQUAL expression SEMICOLON
    (33) assignation -> . access_array EQUAL expression SEMICOLON
    (34) decision -> . IF LPAREN expression_bool RPAREN THEN LBRACE statute RBRACE ELSE LBRACE def_else statute RBRACE
    (35) decision -> . IF LPAREN expression_bool RPAREN THEN LBRACE statute RBRACE
    (37) condition -> . WHILE LPAREN expression_bool_while RPAREN DO LBRACE statute RBRACE
    (46) return -> . RETURN LPAREN expression RPAREN
    (19) function -> . ID LPAREN era_function expression RPAREN
    (38) write -> . WRITE LPAREN expression RPAREN
    (39) read -> . READ LPAREN expression RPAREN
    (62) empty -> .
    (31) access_array -> . ID LBRACKET INT RBRACKET

    ID              shift and go to state 49
    IF              shift and go to state 51
    WHILE           shift and go to state 52
    RETURN          shift and go to state 53
    WRITE           shift and go to state 54
    READ            shift and go to state 55
    RBRACE          reduce using rule 62 (empty -> .)

    statute                        shift and go to state 40
    assignation                    shift and go to state 41
    decision                       shift and go to state 42
    condition                      shift and go to state 43
    return                         shift and go to state 44
    function                       shift and go to state 45
    write                          shift and go to state 46
    read                           shift and go to state 47
    empty                          shift and go to state 48
    access_array                   shift and go to state 50

state 37

    (13) define_function -> FUNCTION start_func type ID parameters . VARS define_vars_function LBRACE statute RBRACE end_func define_function

    VARS            shift and go to state 56


state 38

    (22) parameters -> LPAREN . type COLON id_list RPAREN
    (10) type -> . INT
    (11) type -> . FLOAT
    (12) type -> . STRING

    INT             shift and go to state 11
    FLOAT           shift and go to state 12
    STRING          shift and go to state 13

    type                           shift and go to state 57

state 39

    (7) array -> ID LBRACKET INT RBRACKET .

    COMMA           reduce using rule 7 (array -> ID LBRACKET INT RBRACKET .)
    SEMICOLON       reduce using rule 7 (array -> ID LBRACKET INT RBRACKET .)
    RPAREN          reduce using rule 7 (array -> ID LBRACKET INT RBRACKET .)


state 40

    (21) main -> MAIN LPAREN RPAREN LBRACE statute . RBRACE

    RBRACE          shift and go to state 58


state 41

    (23) statute -> assignation . statute
    (23) statute -> . assignation statute
    (24) statute -> . decision statute
    (25) statute -> . condition statute
    (26) statute -> . return statute
    (27) statute -> . function statute
    (28) statute -> . write statute
    (29) statute -> . read statute
    (30) statute -> . empty
    (32) assignation -> . ID EQUAL expression SEMICOLON
    (33) assignation -> . access_array EQUAL expression SEMICOLON
    (34) decision -> . IF LPAREN expression_bool RPAREN THEN LBRACE statute RBRACE ELSE LBRACE def_else statute RBRACE
    (35) decision -> . IF LPAREN expression_bool RPAREN THEN LBRACE statute RBRACE
    (37) condition -> . WHILE LPAREN expression_bool_while RPAREN DO LBRACE statute RBRACE
    (46) return -> . RETURN LPAREN expression RPAREN
    (19) function -> . ID LPAREN era_function expression RPAREN
    (38) write -> . WRITE LPAREN expression RPAREN
    (39) read -> . READ LPAREN expression RPAREN
    (62) empty -> .
    (31) access_array -> . ID LBRACKET INT RBRACKET

    ID              shift and go to state 49
    IF              shift and go to state 51
    WHILE           shift and go to state 52
    RETURN          shift and go to state 53
    WRITE           shift and go to state 54
    READ            shift and go to state 55
    RBRACE          reduce using rule 62 (empty -> .)

    assignation                    shift and go to state 41
    statute                        shift and go to state 59
    decision                       shift and go to state 42
    condition                      shift and go to state 43
    return                         shift and go to state 44
    function                       shift and go to state 45
    write                          shift and go to state 46
    read                           shift and go to state 47
    empty                          shift and go to state 48
    access_array                   shift and go to state 50

state 42

    (24) statute -> decision . statute
    (23) statute -> . assignation statute
    (24) statute -> . decision statute
    (25) statute -> . condition statute
    (26) statute -> . return statute
    (27) statute -> . function statute
    (28) statute -> . write statute
    (29) statute -> . read statute
    (30) statute -> . empty
    (32) assignation -> . ID EQUAL expression SEMICOLON
    (33) assignation -> . access_array EQUAL expression SEMICOLON
    (34) decision -> . IF LPAREN expression_bool RPAREN THEN LBRACE statute RBRACE ELSE LBRACE def_else statute RBRACE
    (35) decision -> . IF LPAREN expression_bool RPAREN THEN LBRACE statute RBRACE
    (37) condition -> . WHILE LPAREN expression_bool_while RPAREN DO LBRACE statute RBRACE
    (46) return -> . RETURN LPAREN expression RPAREN
    (19) function -> . ID LPAREN era_function expression RPAREN
    (38) write -> . WRITE LPAREN expression RPAREN
    (39) read -> . READ LPAREN expression RPAREN
    (62) empty -> .
    (31) access_array -> . ID LBRACKET INT RBRACKET

    ID              shift and go to state 49
    IF              shift and go to state 51
    WHILE           shift and go to state 52
    RETURN          shift and go to state 53
    WRITE           shift and go to state 54
    READ            shift and go to state 55
    RBRACE          reduce using rule 62 (empty -> .)

    decision                       shift and go to state 42
    statute                        shift and go to state 60
    assignation                    shift and go to state 41
    condition                      shift and go to state 43
    return                         shift and go to state 44
    function                       shift and go to state 45
    write                          shift and go to state 46
    read                           shift and go to state 47
    empty                          shift and go to state 48
    access_array                   shift and go to state 50

state 43

    (25) statute -> condition . statute
    (23) statute -> . assignation statute
    (24) statute -> . decision statute
    (25) statute -> . condition statute
    (26) statute -> . return statute
    (27) statute -> . function statute
    (28) statute -> . write statute
    (29) statute -> . read statute
    (30) statute -> . empty
    (32) assignation -> . ID EQUAL expression SEMICOLON
    (33) assignation -> . access_array EQUAL expression SEMICOLON
    (34) decision -> . IF LPAREN expression_bool RPAREN THEN LBRACE statute RBRACE ELSE LBRACE def_else statute RBRACE
    (35) decision -> . IF LPAREN expression_bool RPAREN THEN LBRACE statute RBRACE
    (37) condition -> . WHILE LPAREN expression_bool_while RPAREN DO LBRACE statute RBRACE
    (46) return -> . RETURN LPAREN expression RPAREN
    (19) function -> . ID LPAREN era_function expression RPAREN
    (38) write -> . WRITE LPAREN expression RPAREN
    (39) read -> . READ LPAREN expression RPAREN
    (62) empty -> .
    (31) access_array -> . ID LBRACKET INT RBRACKET

    ID              shift and go to state 49
    IF              shift and go to state 51
    WHILE           shift and go to state 52
    RETURN          shift and go to state 53
    WRITE           shift and go to state 54
    READ            shift and go to state 55
    RBRACE          reduce using rule 62 (empty -> .)

    condition                      shift and go to state 43
    statute                        shift and go to state 61
    assignation                    shift and go to state 41
    decision                       shift and go to state 42
    return                         shift and go to state 44
    function                       shift and go to state 45
    write                          shift and go to state 46
    read                           shift and go to state 47
    empty                          shift and go to state 48
    access_array                   shift and go to state 50

state 44

    (26) statute -> return . statute
    (23) statute -> . assignation statute
    (24) statute -> . decision statute
    (25) statute -> . condition statute
    (26) statute -> . return statute
    (27) statute -> . function statute
    (28) statute -> . write statute
    (29) statute -> . read statute
    (30) statute -> . empty
    (32) assignation -> . ID EQUAL expression SEMICOLON
    (33) assignation -> . access_array EQUAL expression SEMICOLON
    (34) decision -> . IF LPAREN expression_bool RPAREN THEN LBRACE statute RBRACE ELSE LBRACE def_else statute RBRACE
    (35) decision -> . IF LPAREN expression_bool RPAREN THEN LBRACE statute RBRACE
    (37) condition -> . WHILE LPAREN expression_bool_while RPAREN DO LBRACE statute RBRACE
    (46) return -> . RETURN LPAREN expression RPAREN
    (19) function -> . ID LPAREN era_function expression RPAREN
    (38) write -> . WRITE LPAREN expression RPAREN
    (39) read -> . READ LPAREN expression RPAREN
    (62) empty -> .
    (31) access_array -> . ID LBRACKET INT RBRACKET

    ID              shift and go to state 49
    IF              shift and go to state 51
    WHILE           shift and go to state 52
    RETURN          shift and go to state 53
    WRITE           shift and go to state 54
    READ            shift and go to state 55
    RBRACE          reduce using rule 62 (empty -> .)

    return                         shift and go to state 44
    statute                        shift and go to state 62
    assignation                    shift and go to state 41
    decision                       shift and go to state 42
    condition                      shift and go to state 43
    function                       shift and go to state 45
    write                          shift and go to state 46
    read                           shift and go to state 47
    empty                          shift and go to state 48
    access_array                   shift and go to state 50

state 45

    (27) statute -> function . statute
    (23) statute -> . assignation statute
    (24) statute -> . decision statute
    (25) statute -> . condition statute
    (26) statute -> . return statute
    (27) statute -> . function statute
    (28) statute -> . write statute
    (29) statute -> . read statute
    (30) statute -> . empty
    (32) assignation -> . ID EQUAL expression SEMICOLON
    (33) assignation -> . access_array EQUAL expression SEMICOLON
    (34) decision -> . IF LPAREN expression_bool RPAREN THEN LBRACE statute RBRACE ELSE LBRACE def_else statute RBRACE
    (35) decision -> . IF LPAREN expression_bool RPAREN THEN LBRACE statute RBRACE
    (37) condition -> . WHILE LPAREN expression_bool_while RPAREN DO LBRACE statute RBRACE
    (46) return -> . RETURN LPAREN expression RPAREN
    (19) function -> . ID LPAREN era_function expression RPAREN
    (38) write -> . WRITE LPAREN expression RPAREN
    (39) read -> . READ LPAREN expression RPAREN
    (62) empty -> .
    (31) access_array -> . ID LBRACKET INT RBRACKET

    ID              shift and go to state 49
    IF              shift and go to state 51
    WHILE           shift and go to state 52
    RETURN          shift and go to state 53
    WRITE           shift and go to state 54
    READ            shift and go to state 55
    RBRACE          reduce using rule 62 (empty -> .)

    function                       shift and go to state 45
    statute                        shift and go to state 63
    assignation                    shift and go to state 41
    decision                       shift and go to state 42
    condition                      shift and go to state 43
    return                         shift and go to state 44
    write                          shift and go to state 46
    read                           shift and go to state 47
    empty                          shift and go to state 48
    access_array                   shift and go to state 50

state 46

    (28) statute -> write . statute
    (23) statute -> . assignation statute
    (24) statute -> . decision statute
    (25) statute -> . condition statute
    (26) statute -> . return statute
    (27) statute -> . function statute
    (28) statute -> . write statute
    (29) statute -> . read statute
    (30) statute -> . empty
    (32) assignation -> . ID EQUAL expression SEMICOLON
    (33) assignation -> . access_array EQUAL expression SEMICOLON
    (34) decision -> . IF LPAREN expression_bool RPAREN THEN LBRACE statute RBRACE ELSE LBRACE def_else statute RBRACE
    (35) decision -> . IF LPAREN expression_bool RPAREN THEN LBRACE statute RBRACE
    (37) condition -> . WHILE LPAREN expression_bool_while RPAREN DO LBRACE statute RBRACE
    (46) return -> . RETURN LPAREN expression RPAREN
    (19) function -> . ID LPAREN era_function expression RPAREN
    (38) write -> . WRITE LPAREN expression RPAREN
    (39) read -> . READ LPAREN expression RPAREN
    (62) empty -> .
    (31) access_array -> . ID LBRACKET INT RBRACKET

    ID              shift and go to state 49
    IF              shift and go to state 51
    WHILE           shift and go to state 52
    RETURN          shift and go to state 53
    WRITE           shift and go to state 54
    READ            shift and go to state 55
    RBRACE          reduce using rule 62 (empty -> .)

    write                          shift and go to state 46
    statute                        shift and go to state 64
    assignation                    shift and go to state 41
    decision                       shift and go to state 42
    condition                      shift and go to state 43
    return                         shift and go to state 44
    function                       shift and go to state 45
    read                           shift and go to state 47
    empty                          shift and go to state 48
    access_array                   shift and go to state 50

state 47

    (29) statute -> read . statute
    (23) statute -> . assignation statute
    (24) statute -> . decision statute
    (25) statute -> . condition statute
    (26) statute -> . return statute
    (27) statute -> . function statute
    (28) statute -> . write statute
    (29) statute -> . read statute
    (30) statute -> . empty
    (32) assignation -> . ID EQUAL expression SEMICOLON
    (33) assignation -> . access_array EQUAL expression SEMICOLON
    (34) decision -> . IF LPAREN expression_bool RPAREN THEN LBRACE statute RBRACE ELSE LBRACE def_else statute RBRACE
    (35) decision -> . IF LPAREN expression_bool RPAREN THEN LBRACE statute RBRACE
    (37) condition -> . WHILE LPAREN expression_bool_while RPAREN DO LBRACE statute RBRACE
    (46) return -> . RETURN LPAREN expression RPAREN
    (19) function -> . ID LPAREN era_function expression RPAREN
    (38) write -> . WRITE LPAREN expression RPAREN
    (39) read -> . READ LPAREN expression RPAREN
    (62) empty -> .
    (31) access_array -> . ID LBRACKET INT RBRACKET

    ID              shift and go to state 49
    IF              shift and go to state 51
    WHILE           shift and go to state 52
    RETURN          shift and go to state 53
    WRITE           shift and go to state 54
    READ            shift and go to state 55
    RBRACE          reduce using rule 62 (empty -> .)

    read                           shift and go to state 47
    statute                        shift and go to state 65
    assignation                    shift and go to state 41
    decision                       shift and go to state 42
    condition                      shift and go to state 43
    return                         shift and go to state 44
    function                       shift and go to state 45
    write                          shift and go to state 46
    empty                          shift and go to state 48
    access_array                   shift and go to state 50

state 48

    (30) statute -> empty .

    RBRACE          reduce using rule 30 (statute -> empty .)


state 49

    (32) assignation -> ID . EQUAL expression SEMICOLON
    (19) function -> ID . LPAREN era_function expression RPAREN
    (31) access_array -> ID . LBRACKET INT RBRACKET

    EQUAL           shift and go to state 66
    LPAREN          shift and go to state 67
    LBRACKET        shift and go to state 68


state 50

    (33) assignation -> access_array . EQUAL expression SEMICOLON

    EQUAL           shift and go to state 69


state 51

    (34) decision -> IF . LPAREN expression_bool RPAREN THEN LBRACE statute RBRACE ELSE LBRACE def_else statute RBRACE
    (35) decision -> IF . LPAREN expression_bool RPAREN THEN LBRACE statute RBRACE

    LPAREN          shift and go to state 70


state 52

    (37) condition -> WHILE . LPAREN expression_bool_while RPAREN DO LBRACE statute RBRACE

    LPAREN          shift and go to state 71


state 53

    (46) return -> RETURN . LPAREN expression RPAREN

    LPAREN          shift and go to state 72


state 54

    (38) write -> WRITE . LPAREN expression RPAREN

    LPAREN          shift and go to state 73


state 55

    (39) read -> READ . LPAREN expression RPAREN

    LPAREN          shift and go to state 74


state 56

    (13) define_function -> FUNCTION start_func type ID parameters VARS . define_vars_function LBRACE statute RBRACE end_func define_function
    (17) define_vars_function -> . type COLON id_list SEMICOLON define_vars_function
    (18) define_vars_function -> . empty
    (10) type -> . INT
    (11) type -> . FLOAT
    (12) type -> . STRING
    (62) empty -> .

    INT             shift and go to state 11
    FLOAT           shift and go to state 12
    STRING          shift and go to state 13
    LBRACE          reduce using rule 62 (empty -> .)

    type                           shift and go to state 75
    define_vars_function           shift and go to state 76
    empty                          shift and go to state 77

state 57

    (22) parameters -> LPAREN type . COLON id_list RPAREN

    COLON           shift and go to state 78


state 58

    (21) main -> MAIN LPAREN RPAREN LBRACE statute RBRACE .

    $end            reduce using rule 21 (main -> MAIN LPAREN RPAREN LBRACE statute RBRACE .)


state 59

    (23) statute -> assignation statute .

    RBRACE          reduce using rule 23 (statute -> assignation statute .)


state 60

    (24) statute -> decision statute .

    RBRACE          reduce using rule 24 (statute -> decision statute .)


state 61

    (25) statute -> condition statute .

    RBRACE          reduce using rule 25 (statute -> condition statute .)


state 62

    (26) statute -> return statute .

    RBRACE          reduce using rule 26 (statute -> return statute .)


state 63

    (27) statute -> function statute .

    RBRACE          reduce using rule 27 (statute -> function statute .)


state 64

    (28) statute -> write statute .

    RBRACE          reduce using rule 28 (statute -> write statute .)


state 65

    (29) statute -> read statute .

    RBRACE          reduce using rule 29 (statute -> read statute .)


state 66

    (32) assignation -> ID EQUAL . expression SEMICOLON
    (47) expression -> . expression PLUS term
    (48) expression -> . expression MINUS term
    (49) expression -> . term
    (50) term -> . term TIMES factor
    (51) term -> . term DIVIDE factor
    (52) term -> . factor
    (53) factor -> . FLOAT
    (54) factor -> . INT
    (55) factor -> . STRING
    (56) factor -> . function
    (57) factor -> . access_array
    (58) factor -> . ID
    (59) factor -> . PLUS factor
    (60) factor -> . MINUS factor
    (61) factor -> . LPAREN expression RPAREN
    (19) function -> . ID LPAREN era_function expression RPAREN
    (31) access_array -> . ID LBRACKET INT RBRACKET

    FLOAT           shift and go to state 85
    INT             shift and go to state 86
    STRING          shift and go to state 87
    ID              shift and go to state 79
    PLUS            shift and go to state 81
    MINUS           shift and go to state 83
    LPAREN          shift and go to state 90

    expression                     shift and go to state 80
    term                           shift and go to state 82
    factor                         shift and go to state 84
    function                       shift and go to state 88
    access_array                   shift and go to state 89

state 67

    (19) function -> ID LPAREN . era_function expression RPAREN
    (20) era_function -> . empty
    (62) empty -> .

    FLOAT           reduce using rule 62 (empty -> .)
    INT             reduce using rule 62 (empty -> .)
    STRING          reduce using rule 62 (empty -> .)
    ID              reduce using rule 62 (empty -> .)
    PLUS            reduce using rule 62 (empty -> .)
    MINUS           reduce using rule 62 (empty -> .)
    LPAREN          reduce using rule 62 (empty -> .)

    era_function                   shift and go to state 91
    empty                          shift and go to state 92

state 68

    (31) access_array -> ID LBRACKET . INT RBRACKET

    INT             shift and go to state 93


state 69

    (33) assignation -> access_array EQUAL . expression SEMICOLON
    (47) expression -> . expression PLUS term
    (48) expression -> . expression MINUS term
    (49) expression -> . term
    (50) term -> . term TIMES factor
    (51) term -> . term DIVIDE factor
    (52) term -> . factor
    (53) factor -> . FLOAT
    (54) factor -> . INT
    (55) factor -> . STRING
    (56) factor -> . function
    (57) factor -> . access_array
    (58) factor -> . ID
    (59) factor -> . PLUS factor
    (60) factor -> . MINUS factor
    (61) factor -> . LPAREN expression RPAREN
    (19) function -> . ID LPAREN era_function expression RPAREN
    (31) access_array -> . ID LBRACKET INT RBRACKET

    FLOAT           shift and go to state 85
    INT             shift and go to state 86
    STRING          shift and go to state 87
    ID              shift and go to state 79
    PLUS            shift and go to state 81
    MINUS           shift and go to state 83
    LPAREN          shift and go to state 90

    access_array                   shift and go to state 89
    expression                     shift and go to state 94
    term                           shift and go to state 82
    factor                         shift and go to state 84
    function                       shift and go to state 88

state 70

    (34) decision -> IF LPAREN . expression_bool RPAREN THEN LBRACE statute RBRACE ELSE LBRACE def_else statute RBRACE
    (35) decision -> IF LPAREN . expression_bool RPAREN THEN LBRACE statute RBRACE
    (40) expression_bool -> . expression GREATERTHAN term
    (41) expression_bool -> . expression SMALLERTHAN term
    (42) expression_bool -> . expression EQUALTO term
    (47) expression -> . expression PLUS term
    (48) expression -> . expression MINUS term
    (49) expression -> . term
    (50) term -> . term TIMES factor
    (51) term -> . term DIVIDE factor
    (52) term -> . factor
    (53) factor -> . FLOAT
    (54) factor -> . INT
    (55) factor -> . STRING
    (56) factor -> . function
    (57) factor -> . access_array
    (58) factor -> . ID
    (59) factor -> . PLUS factor
    (60) factor -> . MINUS factor
    (61) factor -> . LPAREN expression RPAREN
    (19) function -> . ID LPAREN era_function expression RPAREN
    (31) access_array -> . ID LBRACKET INT RBRACKET

    FLOAT           shift and go to state 85
    INT             shift and go to state 86
    STRING          shift and go to state 87
    ID              shift and go to state 79
    PLUS            shift and go to state 81
    MINUS           shift and go to state 83
    LPAREN          shift and go to state 90

    expression_bool                shift and go to state 95
    expression                     shift and go to state 96
    term                           shift and go to state 82
    factor                         shift and go to state 84
    function                       shift and go to state 88
    access_array                   shift and go to state 89

state 71

    (37) condition -> WHILE LPAREN . expression_bool_while RPAREN DO LBRACE statute RBRACE
    (43) expression_bool_while -> . expression GREATERTHAN term
    (44) expression_bool_while -> . expression SMALLERTHAN term
    (45) expression_bool_while -> . expression EQUALTO term
    (47) expression -> . expression PLUS term
    (48) expression -> . expression MINUS term
    (49) expression -> . term
    (50) term -> . term TIMES factor
    (51) term -> . term DIVIDE factor
    (52) term -> . factor
    (53) factor -> . FLOAT
    (54) factor -> . INT
    (55) factor -> . STRING
    (56) factor -> . function
    (57) factor -> . access_array
    (58) factor -> . ID
    (59) factor -> . PLUS factor
    (60) factor -> . MINUS factor
    (61) factor -> . LPAREN expression RPAREN
    (19) function -> . ID LPAREN era_function expression RPAREN
    (31) access_array -> . ID LBRACKET INT RBRACKET

    FLOAT           shift and go to state 85
    INT             shift and go to state 86
    STRING          shift and go to state 87
    ID              shift and go to state 79
    PLUS            shift and go to state 81
    MINUS           shift and go to state 83
    LPAREN          shift and go to state 90

    expression_bool_while          shift and go to state 97
    expression                     shift and go to state 98
    term                           shift and go to state 82
    factor                         shift and go to state 84
    function                       shift and go to state 88
    access_array                   shift and go to state 89

state 72

    (46) return -> RETURN LPAREN . expression RPAREN
    (47) expression -> . expression PLUS term
    (48) expression -> . expression MINUS term
    (49) expression -> . term
    (50) term -> . term TIMES factor
    (51) term -> . term DIVIDE factor
    (52) term -> . factor
    (53) factor -> . FLOAT
    (54) factor -> . INT
    (55) factor -> . STRING
    (56) factor -> . function
    (57) factor -> . access_array
    (58) factor -> . ID
    (59) factor -> . PLUS factor
    (60) factor -> . MINUS factor
    (61) factor -> . LPAREN expression RPAREN
    (19) function -> . ID LPAREN era_function expression RPAREN
    (31) access_array -> . ID LBRACKET INT RBRACKET

    FLOAT           shift and go to state 85
    INT             shift and go to state 86
    STRING          shift and go to state 87
    ID              shift and go to state 79
    PLUS            shift and go to state 81
    MINUS           shift and go to state 83
    LPAREN          shift and go to state 90

    expression                     shift and go to state 99
    term                           shift and go to state 82
    factor                         shift and go to state 84
    function                       shift and go to state 88
    access_array                   shift and go to state 89

state 73

    (38) write -> WRITE LPAREN . expression RPAREN
    (47) expression -> . expression PLUS term
    (48) expression -> . expression MINUS term
    (49) expression -> . term
    (50) term -> . term TIMES factor
    (51) term -> . term DIVIDE factor
    (52) term -> . factor
    (53) factor -> . FLOAT
    (54) factor -> . INT
    (55) factor -> . STRING
    (56) factor -> . function
    (57) factor -> . access_array
    (58) factor -> . ID
    (59) factor -> . PLUS factor
    (60) factor -> . MINUS factor
    (61) factor -> . LPAREN expression RPAREN
    (19) function -> . ID LPAREN era_function expression RPAREN
    (31) access_array -> . ID LBRACKET INT RBRACKET

    FLOAT           shift and go to state 85
    INT             shift and go to state 86
    STRING          shift and go to state 87
    ID              shift and go to state 79
    PLUS            shift and go to state 81
    MINUS           shift and go to state 83
    LPAREN          shift and go to state 90

    expression                     shift and go to state 100
    term                           shift and go to state 82
    factor                         shift and go to state 84
    function                       shift and go to state 88
    access_array                   shift and go to state 89

state 74

    (39) read -> READ LPAREN . expression RPAREN
    (47) expression -> . expression PLUS term
    (48) expression -> . expression MINUS term
    (49) expression -> . term
    (50) term -> . term TIMES factor
    (51) term -> . term DIVIDE factor
    (52) term -> . factor
    (53) factor -> . FLOAT
    (54) factor -> . INT
    (55) factor -> . STRING
    (56) factor -> . function
    (57) factor -> . access_array
    (58) factor -> . ID
    (59) factor -> . PLUS factor
    (60) factor -> . MINUS factor
    (61) factor -> . LPAREN expression RPAREN
    (19) function -> . ID LPAREN era_function expression RPAREN
    (31) access_array -> . ID LBRACKET INT RBRACKET

    FLOAT           shift and go to state 85
    INT             shift and go to state 86
    STRING          shift and go to state 87
    ID              shift and go to state 79
    PLUS            shift and go to state 81
    MINUS           shift and go to state 83
    LPAREN          shift and go to state 90

    expression                     shift and go to state 101
    term                           shift and go to state 82
    factor                         shift and go to state 84
    function                       shift and go to state 88
    access_array                   shift and go to state 89

state 75

    (17) define_vars_function -> type . COLON id_list SEMICOLON define_vars_function

    COLON           shift and go to state 102


state 76

    (13) define_function -> FUNCTION start_func type ID parameters VARS define_vars_function . LBRACE statute RBRACE end_func define_function

    LBRACE          shift and go to state 103


state 77

    (18) define_vars_function -> empty .

    LBRACE          reduce using rule 18 (define_vars_function -> empty .)


state 78

    (22) parameters -> LPAREN type COLON . id_list RPAREN
    (3) id_list -> . id_or_array COMMA id_list
    (4) id_list -> . id_or_array
    (5) id_or_array -> . ID
    (6) id_or_array -> . array
    (7) array -> . ID LBRACKET INT RBRACKET

    ID              shift and go to state 24

    id_list                        shift and go to state 104
    id_or_array                    shift and go to state 23
    array                          shift and go to state 25

state 79

    (58) factor -> ID .
    (19) function -> ID . LPAREN era_function expression RPAREN
    (31) access_array -> ID . LBRACKET INT RBRACKET

    TIMES           reduce using rule 58 (factor -> ID .)
    DIVIDE          reduce using rule 58 (factor -> ID .)
    SEMICOLON       reduce using rule 58 (factor -> ID .)
    PLUS            reduce using rule 58 (factor -> ID .)
    MINUS           reduce using rule 58 (factor -> ID .)
    GREATERTHAN     reduce using rule 58 (factor -> ID .)
    SMALLERTHAN     reduce using rule 58 (factor -> ID .)
    EQUALTO         reduce using rule 58 (factor -> ID .)
    RPAREN          reduce using rule 58 (factor -> ID .)
    LPAREN          shift and go to state 67
    LBRACKET        shift and go to state 68


state 80

    (32) assignation -> ID EQUAL expression . SEMICOLON
    (47) expression -> expression . PLUS term
    (48) expression -> expression . MINUS term

    SEMICOLON       shift and go to state 105
    PLUS            shift and go to state 106
    MINUS           shift and go to state 107


state 81

    (59) factor -> PLUS . factor
    (53) factor -> . FLOAT
    (54) factor -> . INT
    (55) factor -> . STRING
    (56) factor -> . function
    (57) factor -> . access_array
    (58) factor -> . ID
    (59) factor -> . PLUS factor
    (60) factor -> . MINUS factor
    (61) factor -> . LPAREN expression RPAREN
    (19) function -> . ID LPAREN era_function expression RPAREN
    (31) access_array -> . ID LBRACKET INT RBRACKET

    FLOAT           shift and go to state 85
    INT             shift and go to state 86
    STRING          shift and go to state 87
    ID              shift and go to state 79
    PLUS            shift and go to state 81
    MINUS           shift and go to state 83
    LPAREN          shift and go to state 90

    factor                         shift and go to state 108
    function                       shift and go to state 88
    access_array                   shift and go to state 89

state 82

    (49) expression -> term .
    (50) term -> term . TIMES factor
    (51) term -> term . DIVIDE factor

    SEMICOLON       reduce using rule 49 (expression -> term .)
    PLUS            reduce using rule 49 (expression -> term .)
    MINUS           reduce using rule 49 (expression -> term .)
    GREATERTHAN     reduce using rule 49 (expression -> term .)
    SMALLERTHAN     reduce using rule 49 (expression -> term .)
    EQUALTO         reduce using rule 49 (expression -> term .)
    RPAREN          reduce using rule 49 (expression -> term .)
    TIMES           shift and go to state 109
    DIVIDE          shift and go to state 110


state 83

    (60) factor -> MINUS . factor
    (53) factor -> . FLOAT
    (54) factor -> . INT
    (55) factor -> . STRING
    (56) factor -> . function
    (57) factor -> . access_array
    (58) factor -> . ID
    (59) factor -> . PLUS factor
    (60) factor -> . MINUS factor
    (61) factor -> . LPAREN expression RPAREN
    (19) function -> . ID LPAREN era_function expression RPAREN
    (31) access_array -> . ID LBRACKET INT RBRACKET

    FLOAT           shift and go to state 85
    INT             shift and go to state 86
    STRING          shift and go to state 87
    ID              shift and go to state 79
    PLUS            shift and go to state 81
    MINUS           shift and go to state 83
    LPAREN          shift and go to state 90

    factor                         shift and go to state 111
    function                       shift and go to state 88
    access_array                   shift and go to state 89

state 84

    (52) term -> factor .

    TIMES           reduce using rule 52 (term -> factor .)
    DIVIDE          reduce using rule 52 (term -> factor .)
    SEMICOLON       reduce using rule 52 (term -> factor .)
    PLUS            reduce using rule 52 (term -> factor .)
    MINUS           reduce using rule 52 (term -> factor .)
    GREATERTHAN     reduce using rule 52 (term -> factor .)
    SMALLERTHAN     reduce using rule 52 (term -> factor .)
    EQUALTO         reduce using rule 52 (term -> factor .)
    RPAREN          reduce using rule 52 (term -> factor .)


state 85

    (53) factor -> FLOAT .

    TIMES           reduce using rule 53 (factor -> FLOAT .)
    DIVIDE          reduce using rule 53 (factor -> FLOAT .)
    SEMICOLON       reduce using rule 53 (factor -> FLOAT .)
    PLUS            reduce using rule 53 (factor -> FLOAT .)
    MINUS           reduce using rule 53 (factor -> FLOAT .)
    GREATERTHAN     reduce using rule 53 (factor -> FLOAT .)
    SMALLERTHAN     reduce using rule 53 (factor -> FLOAT .)
    EQUALTO         reduce using rule 53 (factor -> FLOAT .)
    RPAREN          reduce using rule 53 (factor -> FLOAT .)


state 86

    (54) factor -> INT .

    TIMES           reduce using rule 54 (factor -> INT .)
    DIVIDE          reduce using rule 54 (factor -> INT .)
    SEMICOLON       reduce using rule 54 (factor -> INT .)
    PLUS            reduce using rule 54 (factor -> INT .)
    MINUS           reduce using rule 54 (factor -> INT .)
    GREATERTHAN     reduce using rule 54 (factor -> INT .)
    SMALLERTHAN     reduce using rule 54 (factor -> INT .)
    EQUALTO         reduce using rule 54 (factor -> INT .)
    RPAREN          reduce using rule 54 (factor -> INT .)


state 87

    (55) factor -> STRING .

    TIMES           reduce using rule 55 (factor -> STRING .)
    DIVIDE          reduce using rule 55 (factor -> STRING .)
    SEMICOLON       reduce using rule 55 (factor -> STRING .)
    PLUS            reduce using rule 55 (factor -> STRING .)
    MINUS           reduce using rule 55 (factor -> STRING .)
    GREATERTHAN     reduce using rule 55 (factor -> STRING .)
    SMALLERTHAN     reduce using rule 55 (factor -> STRING .)
    EQUALTO         reduce using rule 55 (factor -> STRING .)
    RPAREN          reduce using rule 55 (factor -> STRING .)


state 88

    (56) factor -> function .

    TIMES           reduce using rule 56 (factor -> function .)
    DIVIDE          reduce using rule 56 (factor -> function .)
    SEMICOLON       reduce using rule 56 (factor -> function .)
    PLUS            reduce using rule 56 (factor -> function .)
    MINUS           reduce using rule 56 (factor -> function .)
    GREATERTHAN     reduce using rule 56 (factor -> function .)
    SMALLERTHAN     reduce using rule 56 (factor -> function .)
    EQUALTO         reduce using rule 56 (factor -> function .)
    RPAREN          reduce using rule 56 (factor -> function .)


state 89

    (57) factor -> access_array .

    TIMES           reduce using rule 57 (factor -> access_array .)
    DIVIDE          reduce using rule 57 (factor -> access_array .)
    SEMICOLON       reduce using rule 57 (factor -> access_array .)
    PLUS            reduce using rule 57 (factor -> access_array .)
    MINUS           reduce using rule 57 (factor -> access_array .)
    GREATERTHAN     reduce using rule 57 (factor -> access_array .)
    SMALLERTHAN     reduce using rule 57 (factor -> access_array .)
    EQUALTO         reduce using rule 57 (factor -> access_array .)
    RPAREN          reduce using rule 57 (factor -> access_array .)


state 90

    (61) factor -> LPAREN . expression RPAREN
    (47) expression -> . expression PLUS term
    (48) expression -> . expression MINUS term
    (49) expression -> . term
    (50) term -> . term TIMES factor
    (51) term -> . term DIVIDE factor
    (52) term -> . factor
    (53) factor -> . FLOAT
    (54) factor -> . INT
    (55) factor -> . STRING
    (56) factor -> . function
    (57) factor -> . access_array
    (58) factor -> . ID
    (59) factor -> . PLUS factor
    (60) factor -> . MINUS factor
    (61) factor -> . LPAREN expression RPAREN
    (19) function -> . ID LPAREN era_function expression RPAREN
    (31) access_array -> . ID LBRACKET INT RBRACKET

    FLOAT           shift and go to state 85
    INT             shift and go to state 86
    STRING          shift and go to state 87
    ID              shift and go to state 79
    PLUS            shift and go to state 81
    MINUS           shift and go to state 83
    LPAREN          shift and go to state 90

    expression                     shift and go to state 112
    term                           shift and go to state 82
    factor                         shift and go to state 84
    function                       shift and go to state 88
    access_array                   shift and go to state 89

state 91

    (19) function -> ID LPAREN era_function . expression RPAREN
    (47) expression -> . expression PLUS term
    (48) expression -> . expression MINUS term
    (49) expression -> . term
    (50) term -> . term TIMES factor
    (51) term -> . term DIVIDE factor
    (52) term -> . factor
    (53) factor -> . FLOAT
    (54) factor -> . INT
    (55) factor -> . STRING
    (56) factor -> . function
    (57) factor -> . access_array
    (58) factor -> . ID
    (59) factor -> . PLUS factor
    (60) factor -> . MINUS factor
    (61) factor -> . LPAREN expression RPAREN
    (19) function -> . ID LPAREN era_function expression RPAREN
    (31) access_array -> . ID LBRACKET INT RBRACKET

    FLOAT           shift and go to state 85
    INT             shift and go to state 86
    STRING          shift and go to state 87
    ID              shift and go to state 79
    PLUS            shift and go to state 81
    MINUS           shift and go to state 83
    LPAREN          shift and go to state 90

    expression                     shift and go to state 113
    term                           shift and go to state 82
    factor                         shift and go to state 84
    function                       shift and go to state 88
    access_array                   shift and go to state 89

state 92

    (20) era_function -> empty .

    FLOAT           reduce using rule 20 (era_function -> empty .)
    INT             reduce using rule 20 (era_function -> empty .)
    STRING          reduce using rule 20 (era_function -> empty .)
    ID              reduce using rule 20 (era_function -> empty .)
    PLUS            reduce using rule 20 (era_function -> empty .)
    MINUS           reduce using rule 20 (era_function -> empty .)
    LPAREN          reduce using rule 20 (era_function -> empty .)


state 93

    (31) access_array -> ID LBRACKET INT . RBRACKET

    RBRACKET        shift and go to state 114


state 94

    (33) assignation -> access_array EQUAL expression . SEMICOLON
    (47) expression -> expression . PLUS term
    (48) expression -> expression . MINUS term

    SEMICOLON       shift and go to state 115
    PLUS            shift and go to state 106
    MINUS           shift and go to state 107


state 95

    (34) decision -> IF LPAREN expression_bool . RPAREN THEN LBRACE statute RBRACE ELSE LBRACE def_else statute RBRACE
    (35) decision -> IF LPAREN expression_bool . RPAREN THEN LBRACE statute RBRACE

    RPAREN          shift and go to state 116


state 96

    (40) expression_bool -> expression . GREATERTHAN term
    (41) expression_bool -> expression . SMALLERTHAN term
    (42) expression_bool -> expression . EQUALTO term
    (47) expression -> expression . PLUS term
    (48) expression -> expression . MINUS term

    GREATERTHAN     shift and go to state 117
    SMALLERTHAN     shift and go to state 118
    EQUALTO         shift and go to state 119
    PLUS            shift and go to state 106
    MINUS           shift and go to state 107


state 97

    (37) condition -> WHILE LPAREN expression_bool_while . RPAREN DO LBRACE statute RBRACE

    RPAREN          shift and go to state 120


state 98

    (43) expression_bool_while -> expression . GREATERTHAN term
    (44) expression_bool_while -> expression . SMALLERTHAN term
    (45) expression_bool_while -> expression . EQUALTO term
    (47) expression -> expression . PLUS term
    (48) expression -> expression . MINUS term

    GREATERTHAN     shift and go to state 121
    SMALLERTHAN     shift and go to state 122
    EQUALTO         shift and go to state 123
    PLUS            shift and go to state 106
    MINUS           shift and go to state 107


state 99

    (46) return -> RETURN LPAREN expression . RPAREN
    (47) expression -> expression . PLUS term
    (48) expression -> expression . MINUS term

    RPAREN          shift and go to state 124
    PLUS            shift and go to state 106
    MINUS           shift and go to state 107


state 100

    (38) write -> WRITE LPAREN expression . RPAREN
    (47) expression -> expression . PLUS term
    (48) expression -> expression . MINUS term

    RPAREN          shift and go to state 125
    PLUS            shift and go to state 106
    MINUS           shift and go to state 107


state 101

    (39) read -> READ LPAREN expression . RPAREN
    (47) expression -> expression . PLUS term
    (48) expression -> expression . MINUS term

    RPAREN          shift and go to state 126
    PLUS            shift and go to state 106
    MINUS           shift and go to state 107


state 102

    (17) define_vars_function -> type COLON . id_list SEMICOLON define_vars_function
    (3) id_list -> . id_or_array COMMA id_list
    (4) id_list -> . id_or_array
    (5) id_or_array -> . ID
    (6) id_or_array -> . array
    (7) array -> . ID LBRACKET INT RBRACKET

    ID              shift and go to state 24

    id_list                        shift and go to state 127
    id_or_array                    shift and go to state 23
    array                          shift and go to state 25

state 103

    (13) define_function -> FUNCTION start_func type ID parameters VARS define_vars_function LBRACE . statute RBRACE end_func define_function
    (23) statute -> . assignation statute
    (24) statute -> . decision statute
    (25) statute -> . condition statute
    (26) statute -> . return statute
    (27) statute -> . function statute
    (28) statute -> . write statute
    (29) statute -> . read statute
    (30) statute -> . empty
    (32) assignation -> . ID EQUAL expression SEMICOLON
    (33) assignation -> . access_array EQUAL expression SEMICOLON
    (34) decision -> . IF LPAREN expression_bool RPAREN THEN LBRACE statute RBRACE ELSE LBRACE def_else statute RBRACE
    (35) decision -> . IF LPAREN expression_bool RPAREN THEN LBRACE statute RBRACE
    (37) condition -> . WHILE LPAREN expression_bool_while RPAREN DO LBRACE statute RBRACE
    (46) return -> . RETURN LPAREN expression RPAREN
    (19) function -> . ID LPAREN era_function expression RPAREN
    (38) write -> . WRITE LPAREN expression RPAREN
    (39) read -> . READ LPAREN expression RPAREN
    (62) empty -> .
    (31) access_array -> . ID LBRACKET INT RBRACKET

    ID              shift and go to state 49
    IF              shift and go to state 51
    WHILE           shift and go to state 52
    RETURN          shift and go to state 53
    WRITE           shift and go to state 54
    READ            shift and go to state 55
    RBRACE          reduce using rule 62 (empty -> .)

    statute                        shift and go to state 128
    assignation                    shift and go to state 41
    decision                       shift and go to state 42
    condition                      shift and go to state 43
    return                         shift and go to state 44
    function                       shift and go to state 45
    write                          shift and go to state 46
    read                           shift and go to state 47
    empty                          shift and go to state 48
    access_array                   shift and go to state 50

state 104

    (22) parameters -> LPAREN type COLON id_list . RPAREN

    RPAREN          shift and go to state 129


state 105

    (32) assignation -> ID EQUAL expression SEMICOLON .

    ID              reduce using rule 32 (assignation -> ID EQUAL expression SEMICOLON .)
    IF              reduce using rule 32 (assignation -> ID EQUAL expression SEMICOLON .)
    WHILE           reduce using rule 32 (assignation -> ID EQUAL expression SEMICOLON .)
    RETURN          reduce using rule 32 (assignation -> ID EQUAL expression SEMICOLON .)
    WRITE           reduce using rule 32 (assignation -> ID EQUAL expression SEMICOLON .)
    READ            reduce using rule 32 (assignation -> ID EQUAL expression SEMICOLON .)
    RBRACE          reduce using rule 32 (assignation -> ID EQUAL expression SEMICOLON .)


state 106

    (47) expression -> expression PLUS . term
    (50) term -> . term TIMES factor
    (51) term -> . term DIVIDE factor
    (52) term -> . factor
    (53) factor -> . FLOAT
    (54) factor -> . INT
    (55) factor -> . STRING
    (56) factor -> . function
    (57) factor -> . access_array
    (58) factor -> . ID
    (59) factor -> . PLUS factor
    (60) factor -> . MINUS factor
    (61) factor -> . LPAREN expression RPAREN
    (19) function -> . ID LPAREN era_function expression RPAREN
    (31) access_array -> . ID LBRACKET INT RBRACKET

    FLOAT           shift and go to state 85
    INT             shift and go to state 86
    STRING          shift and go to state 87
    ID              shift and go to state 79
    PLUS            shift and go to state 81
    MINUS           shift and go to state 83
    LPAREN          shift and go to state 90

    term                           shift and go to state 130
    factor                         shift and go to state 84
    function                       shift and go to state 88
    access_array                   shift and go to state 89

state 107

    (48) expression -> expression MINUS . term
    (50) term -> . term TIMES factor
    (51) term -> . term DIVIDE factor
    (52) term -> . factor
    (53) factor -> . FLOAT
    (54) factor -> . INT
    (55) factor -> . STRING
    (56) factor -> . function
    (57) factor -> . access_array
    (58) factor -> . ID
    (59) factor -> . PLUS factor
    (60) factor -> . MINUS factor
    (61) factor -> . LPAREN expression RPAREN
    (19) function -> . ID LPAREN era_function expression RPAREN
    (31) access_array -> . ID LBRACKET INT RBRACKET

    FLOAT           shift and go to state 85
    INT             shift and go to state 86
    STRING          shift and go to state 87
    ID              shift and go to state 79
    PLUS            shift and go to state 81
    MINUS           shift and go to state 83
    LPAREN          shift and go to state 90

    term                           shift and go to state 131
    factor                         shift and go to state 84
    function                       shift and go to state 88
    access_array                   shift and go to state 89

state 108

    (59) factor -> PLUS factor .

    TIMES           reduce using rule 59 (factor -> PLUS factor .)
    DIVIDE          reduce using rule 59 (factor -> PLUS factor .)
    SEMICOLON       reduce using rule 59 (factor -> PLUS factor .)
    PLUS            reduce using rule 59 (factor -> PLUS factor .)
    MINUS           reduce using rule 59 (factor -> PLUS factor .)
    GREATERTHAN     reduce using rule 59 (factor -> PLUS factor .)
    SMALLERTHAN     reduce using rule 59 (factor -> PLUS factor .)
    EQUALTO         reduce using rule 59 (factor -> PLUS factor .)
    RPAREN          reduce using rule 59 (factor -> PLUS factor .)


state 109

    (50) term -> term TIMES . factor
    (53) factor -> . FLOAT
    (54) factor -> . INT
    (55) factor -> . STRING
    (56) factor -> . function
    (57) factor -> . access_array
    (58) factor -> . ID
    (59) factor -> . PLUS factor
    (60) factor -> . MINUS factor
    (61) factor -> . LPAREN expression RPAREN
    (19) function -> . ID LPAREN era_function expression RPAREN
    (31) access_array -> . ID LBRACKET INT RBRACKET

    FLOAT           shift and go to state 85
    INT             shift and go to state 86
    STRING          shift and go to state 87
    ID              shift and go to state 79
    PLUS            shift and go to state 81
    MINUS           shift and go to state 83
    LPAREN          shift and go to state 90

    factor                         shift and go to state 132
    function                       shift and go to state 88
    access_array                   shift and go to state 89

state 110

    (51) term -> term DIVIDE . factor
    (53) factor -> . FLOAT
    (54) factor -> . INT
    (55) factor -> . STRING
    (56) factor -> . function
    (57) factor -> . access_array
    (58) factor -> . ID
    (59) factor -> . PLUS factor
    (60) factor -> . MINUS factor
    (61) factor -> . LPAREN expression RPAREN
    (19) function -> . ID LPAREN era_function expression RPAREN
    (31) access_array -> . ID LBRACKET INT RBRACKET

    FLOAT           shift and go to state 85
    INT             shift and go to state 86
    STRING          shift and go to state 87
    ID              shift and go to state 79
    PLUS            shift and go to state 81
    MINUS           shift and go to state 83
    LPAREN          shift and go to state 90

    factor                         shift and go to state 133
    function                       shift and go to state 88
    access_array                   shift and go to state 89

state 111

    (60) factor -> MINUS factor .

    TIMES           reduce using rule 60 (factor -> MINUS factor .)
    DIVIDE          reduce using rule 60 (factor -> MINUS factor .)
    SEMICOLON       reduce using rule 60 (factor -> MINUS factor .)
    PLUS            reduce using rule 60 (factor -> MINUS factor .)
    MINUS           reduce using rule 60 (factor -> MINUS factor .)
    GREATERTHAN     reduce using rule 60 (factor -> MINUS factor .)
    SMALLERTHAN     reduce using rule 60 (factor -> MINUS factor .)
    EQUALTO         reduce using rule 60 (factor -> MINUS factor .)
    RPAREN          reduce using rule 60 (factor -> MINUS factor .)


state 112

    (61) factor -> LPAREN expression . RPAREN
    (47) expression -> expression . PLUS term
    (48) expression -> expression . MINUS term

    RPAREN          shift and go to state 134
    PLUS            shift and go to state 106
    MINUS           shift and go to state 107


state 113

    (19) function -> ID LPAREN era_function expression . RPAREN
    (47) expression -> expression . PLUS term
    (48) expression -> expression . MINUS term

    RPAREN          shift and go to state 135
    PLUS            shift and go to state 106
    MINUS           shift and go to state 107


state 114

    (31) access_array -> ID LBRACKET INT RBRACKET .

    EQUAL           reduce using rule 31 (access_array -> ID LBRACKET INT RBRACKET .)
    TIMES           reduce using rule 31 (access_array -> ID LBRACKET INT RBRACKET .)
    DIVIDE          reduce using rule 31 (access_array -> ID LBRACKET INT RBRACKET .)
    SEMICOLON       reduce using rule 31 (access_array -> ID LBRACKET INT RBRACKET .)
    PLUS            reduce using rule 31 (access_array -> ID LBRACKET INT RBRACKET .)
    MINUS           reduce using rule 31 (access_array -> ID LBRACKET INT RBRACKET .)
    GREATERTHAN     reduce using rule 31 (access_array -> ID LBRACKET INT RBRACKET .)
    SMALLERTHAN     reduce using rule 31 (access_array -> ID LBRACKET INT RBRACKET .)
    EQUALTO         reduce using rule 31 (access_array -> ID LBRACKET INT RBRACKET .)
    RPAREN          reduce using rule 31 (access_array -> ID LBRACKET INT RBRACKET .)


state 115

    (33) assignation -> access_array EQUAL expression SEMICOLON .

    ID              reduce using rule 33 (assignation -> access_array EQUAL expression SEMICOLON .)
    IF              reduce using rule 33 (assignation -> access_array EQUAL expression SEMICOLON .)
    WHILE           reduce using rule 33 (assignation -> access_array EQUAL expression SEMICOLON .)
    RETURN          reduce using rule 33 (assignation -> access_array EQUAL expression SEMICOLON .)
    WRITE           reduce using rule 33 (assignation -> access_array EQUAL expression SEMICOLON .)
    READ            reduce using rule 33 (assignation -> access_array EQUAL expression SEMICOLON .)
    RBRACE          reduce using rule 33 (assignation -> access_array EQUAL expression SEMICOLON .)


state 116

    (34) decision -> IF LPAREN expression_bool RPAREN . THEN LBRACE statute RBRACE ELSE LBRACE def_else statute RBRACE
    (35) decision -> IF LPAREN expression_bool RPAREN . THEN LBRACE statute RBRACE

    THEN            shift and go to state 136


state 117

    (40) expression_bool -> expression GREATERTHAN . term
    (50) term -> . term TIMES factor
    (51) term -> . term DIVIDE factor
    (52) term -> . factor
    (53) factor -> . FLOAT
    (54) factor -> . INT
    (55) factor -> . STRING
    (56) factor -> . function
    (57) factor -> . access_array
    (58) factor -> . ID
    (59) factor -> . PLUS factor
    (60) factor -> . MINUS factor
    (61) factor -> . LPAREN expression RPAREN
    (19) function -> . ID LPAREN era_function expression RPAREN
    (31) access_array -> . ID LBRACKET INT RBRACKET

    FLOAT           shift and go to state 85
    INT             shift and go to state 86
    STRING          shift and go to state 87
    ID              shift and go to state 79
    PLUS            shift and go to state 81
    MINUS           shift and go to state 83
    LPAREN          shift and go to state 90

    term                           shift and go to state 137
    factor                         shift and go to state 84
    function                       shift and go to state 88
    access_array                   shift and go to state 89

state 118

    (41) expression_bool -> expression SMALLERTHAN . term
    (50) term -> . term TIMES factor
    (51) term -> . term DIVIDE factor
    (52) term -> . factor
    (53) factor -> . FLOAT
    (54) factor -> . INT
    (55) factor -> . STRING
    (56) factor -> . function
    (57) factor -> . access_array
    (58) factor -> . ID
    (59) factor -> . PLUS factor
    (60) factor -> . MINUS factor
    (61) factor -> . LPAREN expression RPAREN
    (19) function -> . ID LPAREN era_function expression RPAREN
    (31) access_array -> . ID LBRACKET INT RBRACKET

    FLOAT           shift and go to state 85
    INT             shift and go to state 86
    STRING          shift and go to state 87
    ID              shift and go to state 79
    PLUS            shift and go to state 81
    MINUS           shift and go to state 83
    LPAREN          shift and go to state 90

    term                           shift and go to state 138
    factor                         shift and go to state 84
    function                       shift and go to state 88
    access_array                   shift and go to state 89

state 119

    (42) expression_bool -> expression EQUALTO . term
    (50) term -> . term TIMES factor
    (51) term -> . term DIVIDE factor
    (52) term -> . factor
    (53) factor -> . FLOAT
    (54) factor -> . INT
    (55) factor -> . STRING
    (56) factor -> . function
    (57) factor -> . access_array
    (58) factor -> . ID
    (59) factor -> . PLUS factor
    (60) factor -> . MINUS factor
    (61) factor -> . LPAREN expression RPAREN
    (19) function -> . ID LPAREN era_function expression RPAREN
    (31) access_array -> . ID LBRACKET INT RBRACKET

    FLOAT           shift and go to state 85
    INT             shift and go to state 86
    STRING          shift and go to state 87
    ID              shift and go to state 79
    PLUS            shift and go to state 81
    MINUS           shift and go to state 83
    LPAREN          shift and go to state 90

    term                           shift and go to state 139
    factor                         shift and go to state 84
    function                       shift and go to state 88
    access_array                   shift and go to state 89

state 120

    (37) condition -> WHILE LPAREN expression_bool_while RPAREN . DO LBRACE statute RBRACE

    DO              shift and go to state 140


state 121

    (43) expression_bool_while -> expression GREATERTHAN . term
    (50) term -> . term TIMES factor
    (51) term -> . term DIVIDE factor
    (52) term -> . factor
    (53) factor -> . FLOAT
    (54) factor -> . INT
    (55) factor -> . STRING
    (56) factor -> . function
    (57) factor -> . access_array
    (58) factor -> . ID
    (59) factor -> . PLUS factor
    (60) factor -> . MINUS factor
    (61) factor -> . LPAREN expression RPAREN
    (19) function -> . ID LPAREN era_function expression RPAREN
    (31) access_array -> . ID LBRACKET INT RBRACKET

    FLOAT           shift and go to state 85
    INT             shift and go to state 86
    STRING          shift and go to state 87
    ID              shift and go to state 79
    PLUS            shift and go to state 81
    MINUS           shift and go to state 83
    LPAREN          shift and go to state 90

    term                           shift and go to state 141
    factor                         shift and go to state 84
    function                       shift and go to state 88
    access_array                   shift and go to state 89

state 122

    (44) expression_bool_while -> expression SMALLERTHAN . term
    (50) term -> . term TIMES factor
    (51) term -> . term DIVIDE factor
    (52) term -> . factor
    (53) factor -> . FLOAT
    (54) factor -> . INT
    (55) factor -> . STRING
    (56) factor -> . function
    (57) factor -> . access_array
    (58) factor -> . ID
    (59) factor -> . PLUS factor
    (60) factor -> . MINUS factor
    (61) factor -> . LPAREN expression RPAREN
    (19) function -> . ID LPAREN era_function expression RPAREN
    (31) access_array -> . ID LBRACKET INT RBRACKET

    FLOAT           shift and go to state 85
    INT             shift and go to state 86
    STRING          shift and go to state 87
    ID              shift and go to state 79
    PLUS            shift and go to state 81
    MINUS           shift and go to state 83
    LPAREN          shift and go to state 90

    term                           shift and go to state 142
    factor                         shift and go to state 84
    function                       shift and go to state 88
    access_array                   shift and go to state 89

state 123

    (45) expression_bool_while -> expression EQUALTO . term
    (50) term -> . term TIMES factor
    (51) term -> . term DIVIDE factor
    (52) term -> . factor
    (53) factor -> . FLOAT
    (54) factor -> . INT
    (55) factor -> . STRING
    (56) factor -> . function
    (57) factor -> . access_array
    (58) factor -> . ID
    (59) factor -> . PLUS factor
    (60) factor -> . MINUS factor
    (61) factor -> . LPAREN expression RPAREN
    (19) function -> . ID LPAREN era_function expression RPAREN
    (31) access_array -> . ID LBRACKET INT RBRACKET

    FLOAT           shift and go to state 85
    INT             shift and go to state 86
    STRING          shift and go to state 87
    ID              shift and go to state 79
    PLUS            shift and go to state 81
    MINUS           shift and go to state 83
    LPAREN          shift and go to state 90

    term                           shift and go to state 143
    factor                         shift and go to state 84
    function                       shift and go to state 88
    access_array                   shift and go to state 89

state 124

    (46) return -> RETURN LPAREN expression RPAREN .

    ID              reduce using rule 46 (return -> RETURN LPAREN expression RPAREN .)
    IF              reduce using rule 46 (return -> RETURN LPAREN expression RPAREN .)
    WHILE           reduce using rule 46 (return -> RETURN LPAREN expression RPAREN .)
    RETURN          reduce using rule 46 (return -> RETURN LPAREN expression RPAREN .)
    WRITE           reduce using rule 46 (return -> RETURN LPAREN expression RPAREN .)
    READ            reduce using rule 46 (return -> RETURN LPAREN expression RPAREN .)
    RBRACE          reduce using rule 46 (return -> RETURN LPAREN expression RPAREN .)


state 125

    (38) write -> WRITE LPAREN expression RPAREN .

    ID              reduce using rule 38 (write -> WRITE LPAREN expression RPAREN .)
    IF              reduce using rule 38 (write -> WRITE LPAREN expression RPAREN .)
    WHILE           reduce using rule 38 (write -> WRITE LPAREN expression RPAREN .)
    RETURN          reduce using rule 38 (write -> WRITE LPAREN expression RPAREN .)
    WRITE           reduce using rule 38 (write -> WRITE LPAREN expression RPAREN .)
    READ            reduce using rule 38 (write -> WRITE LPAREN expression RPAREN .)
    RBRACE          reduce using rule 38 (write -> WRITE LPAREN expression RPAREN .)


state 126

    (39) read -> READ LPAREN expression RPAREN .

    ID              reduce using rule 39 (read -> READ LPAREN expression RPAREN .)
    IF              reduce using rule 39 (read -> READ LPAREN expression RPAREN .)
    WHILE           reduce using rule 39 (read -> READ LPAREN expression RPAREN .)
    RETURN          reduce using rule 39 (read -> READ LPAREN expression RPAREN .)
    WRITE           reduce using rule 39 (read -> READ LPAREN expression RPAREN .)
    READ            reduce using rule 39 (read -> READ LPAREN expression RPAREN .)
    RBRACE          reduce using rule 39 (read -> READ LPAREN expression RPAREN .)


state 127

    (17) define_vars_function -> type COLON id_list . SEMICOLON define_vars_function

    SEMICOLON       shift and go to state 144


state 128

    (13) define_function -> FUNCTION start_func type ID parameters VARS define_vars_function LBRACE statute . RBRACE end_func define_function

    RBRACE          shift and go to state 145


state 129

    (22) parameters -> LPAREN type COLON id_list RPAREN .

    VARS            reduce using rule 22 (parameters -> LPAREN type COLON id_list RPAREN .)


state 130

    (47) expression -> expression PLUS term .
    (50) term -> term . TIMES factor
    (51) term -> term . DIVIDE factor

    SEMICOLON       reduce using rule 47 (expression -> expression PLUS term .)
    PLUS            reduce using rule 47 (expression -> expression PLUS term .)
    MINUS           reduce using rule 47 (expression -> expression PLUS term .)
    GREATERTHAN     reduce using rule 47 (expression -> expression PLUS term .)
    SMALLERTHAN     reduce using rule 47 (expression -> expression PLUS term .)
    EQUALTO         reduce using rule 47 (expression -> expression PLUS term .)
    RPAREN          reduce using rule 47 (expression -> expression PLUS term .)
    TIMES           shift and go to state 109
    DIVIDE          shift and go to state 110


state 131

    (48) expression -> expression MINUS term .
    (50) term -> term . TIMES factor
    (51) term -> term . DIVIDE factor

    SEMICOLON       reduce using rule 48 (expression -> expression MINUS term .)
    PLUS            reduce using rule 48 (expression -> expression MINUS term .)
    MINUS           reduce using rule 48 (expression -> expression MINUS term .)
    GREATERTHAN     reduce using rule 48 (expression -> expression MINUS term .)
    SMALLERTHAN     reduce using rule 48 (expression -> expression MINUS term .)
    EQUALTO         reduce using rule 48 (expression -> expression MINUS term .)
    RPAREN          reduce using rule 48 (expression -> expression MINUS term .)
    TIMES           shift and go to state 109
    DIVIDE          shift and go to state 110


state 132

    (50) term -> term TIMES factor .

    TIMES           reduce using rule 50 (term -> term TIMES factor .)
    DIVIDE          reduce using rule 50 (term -> term TIMES factor .)
    SEMICOLON       reduce using rule 50 (term -> term TIMES factor .)
    PLUS            reduce using rule 50 (term -> term TIMES factor .)
    MINUS           reduce using rule 50 (term -> term TIMES factor .)
    GREATERTHAN     reduce using rule 50 (term -> term TIMES factor .)
    SMALLERTHAN     reduce using rule 50 (term -> term TIMES factor .)
    EQUALTO         reduce using rule 50 (term -> term TIMES factor .)
    RPAREN          reduce using rule 50 (term -> term TIMES factor .)


state 133

    (51) term -> term DIVIDE factor .

    TIMES           reduce using rule 51 (term -> term DIVIDE factor .)
    DIVIDE          reduce using rule 51 (term -> term DIVIDE factor .)
    SEMICOLON       reduce using rule 51 (term -> term DIVIDE factor .)
    PLUS            reduce using rule 51 (term -> term DIVIDE factor .)
    MINUS           reduce using rule 51 (term -> term DIVIDE factor .)
    GREATERTHAN     reduce using rule 51 (term -> term DIVIDE factor .)
    SMALLERTHAN     reduce using rule 51 (term -> term DIVIDE factor .)
    EQUALTO         reduce using rule 51 (term -> term DIVIDE factor .)
    RPAREN          reduce using rule 51 (term -> term DIVIDE factor .)


state 134

    (61) factor -> LPAREN expression RPAREN .

    TIMES           reduce using rule 61 (factor -> LPAREN expression RPAREN .)
    DIVIDE          reduce using rule 61 (factor -> LPAREN expression RPAREN .)
    SEMICOLON       reduce using rule 61 (factor -> LPAREN expression RPAREN .)
    PLUS            reduce using rule 61 (factor -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 61 (factor -> LPAREN expression RPAREN .)
    GREATERTHAN     reduce using rule 61 (factor -> LPAREN expression RPAREN .)
    SMALLERTHAN     reduce using rule 61 (factor -> LPAREN expression RPAREN .)
    EQUALTO         reduce using rule 61 (factor -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 61 (factor -> LPAREN expression RPAREN .)


state 135

    (19) function -> ID LPAREN era_function expression RPAREN .

    ID              reduce using rule 19 (function -> ID LPAREN era_function expression RPAREN .)
    IF              reduce using rule 19 (function -> ID LPAREN era_function expression RPAREN .)
    WHILE           reduce using rule 19 (function -> ID LPAREN era_function expression RPAREN .)
    RETURN          reduce using rule 19 (function -> ID LPAREN era_function expression RPAREN .)
    WRITE           reduce using rule 19 (function -> ID LPAREN era_function expression RPAREN .)
    READ            reduce using rule 19 (function -> ID LPAREN era_function expression RPAREN .)
    RBRACE          reduce using rule 19 (function -> ID LPAREN era_function expression RPAREN .)
    TIMES           reduce using rule 19 (function -> ID LPAREN era_function expression RPAREN .)
    DIVIDE          reduce using rule 19 (function -> ID LPAREN era_function expression RPAREN .)
    SEMICOLON       reduce using rule 19 (function -> ID LPAREN era_function expression RPAREN .)
    PLUS            reduce using rule 19 (function -> ID LPAREN era_function expression RPAREN .)
    MINUS           reduce using rule 19 (function -> ID LPAREN era_function expression RPAREN .)
    GREATERTHAN     reduce using rule 19 (function -> ID LPAREN era_function expression RPAREN .)
    SMALLERTHAN     reduce using rule 19 (function -> ID LPAREN era_function expression RPAREN .)
    EQUALTO         reduce using rule 19 (function -> ID LPAREN era_function expression RPAREN .)
    RPAREN          reduce using rule 19 (function -> ID LPAREN era_function expression RPAREN .)


state 136

    (34) decision -> IF LPAREN expression_bool RPAREN THEN . LBRACE statute RBRACE ELSE LBRACE def_else statute RBRACE
    (35) decision -> IF LPAREN expression_bool RPAREN THEN . LBRACE statute RBRACE

    LBRACE          shift and go to state 146


state 137

    (40) expression_bool -> expression GREATERTHAN term .
    (50) term -> term . TIMES factor
    (51) term -> term . DIVIDE factor

    RPAREN          reduce using rule 40 (expression_bool -> expression GREATERTHAN term .)
    TIMES           shift and go to state 109
    DIVIDE          shift and go to state 110


state 138

    (41) expression_bool -> expression SMALLERTHAN term .
    (50) term -> term . TIMES factor
    (51) term -> term . DIVIDE factor

    RPAREN          reduce using rule 41 (expression_bool -> expression SMALLERTHAN term .)
    TIMES           shift and go to state 109
    DIVIDE          shift and go to state 110


state 139

    (42) expression_bool -> expression EQUALTO term .
    (50) term -> term . TIMES factor
    (51) term -> term . DIVIDE factor

    RPAREN          reduce using rule 42 (expression_bool -> expression EQUALTO term .)
    TIMES           shift and go to state 109
    DIVIDE          shift and go to state 110


state 140

    (37) condition -> WHILE LPAREN expression_bool_while RPAREN DO . LBRACE statute RBRACE

    LBRACE          shift and go to state 147


state 141

    (43) expression_bool_while -> expression GREATERTHAN term .
    (50) term -> term . TIMES factor
    (51) term -> term . DIVIDE factor

    RPAREN          reduce using rule 43 (expression_bool_while -> expression GREATERTHAN term .)
    TIMES           shift and go to state 109
    DIVIDE          shift and go to state 110


state 142

    (44) expression_bool_while -> expression SMALLERTHAN term .
    (50) term -> term . TIMES factor
    (51) term -> term . DIVIDE factor

    RPAREN          reduce using rule 44 (expression_bool_while -> expression SMALLERTHAN term .)
    TIMES           shift and go to state 109
    DIVIDE          shift and go to state 110


state 143

    (45) expression_bool_while -> expression EQUALTO term .
    (50) term -> term . TIMES factor
    (51) term -> term . DIVIDE factor

    RPAREN          reduce using rule 45 (expression_bool_while -> expression EQUALTO term .)
    TIMES           shift and go to state 109
    DIVIDE          shift and go to state 110


state 144

    (17) define_vars_function -> type COLON id_list SEMICOLON . define_vars_function
    (17) define_vars_function -> . type COLON id_list SEMICOLON define_vars_function
    (18) define_vars_function -> . empty
    (10) type -> . INT
    (11) type -> . FLOAT
    (12) type -> . STRING
    (62) empty -> .

    INT             shift and go to state 11
    FLOAT           shift and go to state 12
    STRING          shift and go to state 13
    LBRACE          reduce using rule 62 (empty -> .)

    type                           shift and go to state 75
    define_vars_function           shift and go to state 148
    empty                          shift and go to state 77

state 145

    (13) define_function -> FUNCTION start_func type ID parameters VARS define_vars_function LBRACE statute RBRACE . end_func define_function
    (16) end_func -> . empty
    (62) empty -> .

    FUNCTION        reduce using rule 62 (empty -> .)
    MAIN            reduce using rule 62 (empty -> .)

    end_func                       shift and go to state 149
    empty                          shift and go to state 150

state 146

    (34) decision -> IF LPAREN expression_bool RPAREN THEN LBRACE . statute RBRACE ELSE LBRACE def_else statute RBRACE
    (35) decision -> IF LPAREN expression_bool RPAREN THEN LBRACE . statute RBRACE
    (23) statute -> . assignation statute
    (24) statute -> . decision statute
    (25) statute -> . condition statute
    (26) statute -> . return statute
    (27) statute -> . function statute
    (28) statute -> . write statute
    (29) statute -> . read statute
    (30) statute -> . empty
    (32) assignation -> . ID EQUAL expression SEMICOLON
    (33) assignation -> . access_array EQUAL expression SEMICOLON
    (34) decision -> . IF LPAREN expression_bool RPAREN THEN LBRACE statute RBRACE ELSE LBRACE def_else statute RBRACE
    (35) decision -> . IF LPAREN expression_bool RPAREN THEN LBRACE statute RBRACE
    (37) condition -> . WHILE LPAREN expression_bool_while RPAREN DO LBRACE statute RBRACE
    (46) return -> . RETURN LPAREN expression RPAREN
    (19) function -> . ID LPAREN era_function expression RPAREN
    (38) write -> . WRITE LPAREN expression RPAREN
    (39) read -> . READ LPAREN expression RPAREN
    (62) empty -> .
    (31) access_array -> . ID LBRACKET INT RBRACKET

    ID              shift and go to state 49
    IF              shift and go to state 51
    WHILE           shift and go to state 52
    RETURN          shift and go to state 53
    WRITE           shift and go to state 54
    READ            shift and go to state 55
    RBRACE          reduce using rule 62 (empty -> .)

    statute                        shift and go to state 151
    assignation                    shift and go to state 41
    decision                       shift and go to state 42
    condition                      shift and go to state 43
    return                         shift and go to state 44
    function                       shift and go to state 45
    write                          shift and go to state 46
    read                           shift and go to state 47
    empty                          shift and go to state 48
    access_array                   shift and go to state 50

state 147

    (37) condition -> WHILE LPAREN expression_bool_while RPAREN DO LBRACE . statute RBRACE
    (23) statute -> . assignation statute
    (24) statute -> . decision statute
    (25) statute -> . condition statute
    (26) statute -> . return statute
    (27) statute -> . function statute
    (28) statute -> . write statute
    (29) statute -> . read statute
    (30) statute -> . empty
    (32) assignation -> . ID EQUAL expression SEMICOLON
    (33) assignation -> . access_array EQUAL expression SEMICOLON
    (34) decision -> . IF LPAREN expression_bool RPAREN THEN LBRACE statute RBRACE ELSE LBRACE def_else statute RBRACE
    (35) decision -> . IF LPAREN expression_bool RPAREN THEN LBRACE statute RBRACE
    (37) condition -> . WHILE LPAREN expression_bool_while RPAREN DO LBRACE statute RBRACE
    (46) return -> . RETURN LPAREN expression RPAREN
    (19) function -> . ID LPAREN era_function expression RPAREN
    (38) write -> . WRITE LPAREN expression RPAREN
    (39) read -> . READ LPAREN expression RPAREN
    (62) empty -> .
    (31) access_array -> . ID LBRACKET INT RBRACKET

    ID              shift and go to state 49
    IF              shift and go to state 51
    WHILE           shift and go to state 52
    RETURN          shift and go to state 53
    WRITE           shift and go to state 54
    READ            shift and go to state 55
    RBRACE          reduce using rule 62 (empty -> .)

    statute                        shift and go to state 152
    assignation                    shift and go to state 41
    decision                       shift and go to state 42
    condition                      shift and go to state 43
    return                         shift and go to state 44
    function                       shift and go to state 45
    write                          shift and go to state 46
    read                           shift and go to state 47
    empty                          shift and go to state 48
    access_array                   shift and go to state 50

state 148

    (17) define_vars_function -> type COLON id_list SEMICOLON define_vars_function .

    LBRACE          reduce using rule 17 (define_vars_function -> type COLON id_list SEMICOLON define_vars_function .)


state 149

    (13) define_function -> FUNCTION start_func type ID parameters VARS define_vars_function LBRACE statute RBRACE end_func . define_function
    (13) define_function -> . FUNCTION start_func type ID parameters VARS define_vars_function LBRACE statute RBRACE end_func define_function
    (14) define_function -> . empty
    (62) empty -> .

    FUNCTION        shift and go to state 15
    MAIN            reduce using rule 62 (empty -> .)

    define_function                shift and go to state 153
    empty                          shift and go to state 16

state 150

    (16) end_func -> empty .

    FUNCTION        reduce using rule 16 (end_func -> empty .)
    MAIN            reduce using rule 16 (end_func -> empty .)


state 151

    (34) decision -> IF LPAREN expression_bool RPAREN THEN LBRACE statute . RBRACE ELSE LBRACE def_else statute RBRACE
    (35) decision -> IF LPAREN expression_bool RPAREN THEN LBRACE statute . RBRACE

    RBRACE          shift and go to state 154


state 152

    (37) condition -> WHILE LPAREN expression_bool_while RPAREN DO LBRACE statute . RBRACE

    RBRACE          shift and go to state 155


state 153

    (13) define_function -> FUNCTION start_func type ID parameters VARS define_vars_function LBRACE statute RBRACE end_func define_function .

    MAIN            reduce using rule 13 (define_function -> FUNCTION start_func type ID parameters VARS define_vars_function LBRACE statute RBRACE end_func define_function .)


state 154

    (34) decision -> IF LPAREN expression_bool RPAREN THEN LBRACE statute RBRACE . ELSE LBRACE def_else statute RBRACE
    (35) decision -> IF LPAREN expression_bool RPAREN THEN LBRACE statute RBRACE .

    ELSE            shift and go to state 156
    ID              reduce using rule 35 (decision -> IF LPAREN expression_bool RPAREN THEN LBRACE statute RBRACE .)
    IF              reduce using rule 35 (decision -> IF LPAREN expression_bool RPAREN THEN LBRACE statute RBRACE .)
    WHILE           reduce using rule 35 (decision -> IF LPAREN expression_bool RPAREN THEN LBRACE statute RBRACE .)
    RETURN          reduce using rule 35 (decision -> IF LPAREN expression_bool RPAREN THEN LBRACE statute RBRACE .)
    WRITE           reduce using rule 35 (decision -> IF LPAREN expression_bool RPAREN THEN LBRACE statute RBRACE .)
    READ            reduce using rule 35 (decision -> IF LPAREN expression_bool RPAREN THEN LBRACE statute RBRACE .)
    RBRACE          reduce using rule 35 (decision -> IF LPAREN expression_bool RPAREN THEN LBRACE statute RBRACE .)


state 155

    (37) condition -> WHILE LPAREN expression_bool_while RPAREN DO LBRACE statute RBRACE .

    ID              reduce using rule 37 (condition -> WHILE LPAREN expression_bool_while RPAREN DO LBRACE statute RBRACE .)
    IF              reduce using rule 37 (condition -> WHILE LPAREN expression_bool_while RPAREN DO LBRACE statute RBRACE .)
    WHILE           reduce using rule 37 (condition -> WHILE LPAREN expression_bool_while RPAREN DO LBRACE statute RBRACE .)
    RETURN          reduce using rule 37 (condition -> WHILE LPAREN expression_bool_while RPAREN DO LBRACE statute RBRACE .)
    WRITE           reduce using rule 37 (condition -> WHILE LPAREN expression_bool_while RPAREN DO LBRACE statute RBRACE .)
    READ            reduce using rule 37 (condition -> WHILE LPAREN expression_bool_while RPAREN DO LBRACE statute RBRACE .)
    RBRACE          reduce using rule 37 (condition -> WHILE LPAREN expression_bool_while RPAREN DO LBRACE statute RBRACE .)


state 156

    (34) decision -> IF LPAREN expression_bool RPAREN THEN LBRACE statute RBRACE ELSE . LBRACE def_else statute RBRACE

    LBRACE          shift and go to state 157


state 157

    (34) decision -> IF LPAREN expression_bool RPAREN THEN LBRACE statute RBRACE ELSE LBRACE . def_else statute RBRACE
    (36) def_else -> . empty
    (62) empty -> .

    ID              reduce using rule 62 (empty -> .)
    IF              reduce using rule 62 (empty -> .)
    WHILE           reduce using rule 62 (empty -> .)
    RETURN          reduce using rule 62 (empty -> .)
    WRITE           reduce using rule 62 (empty -> .)
    READ            reduce using rule 62 (empty -> .)
    RBRACE          reduce using rule 62 (empty -> .)

    def_else                       shift and go to state 158
    empty                          shift and go to state 159

state 158

    (34) decision -> IF LPAREN expression_bool RPAREN THEN LBRACE statute RBRACE ELSE LBRACE def_else . statute RBRACE
    (23) statute -> . assignation statute
    (24) statute -> . decision statute
    (25) statute -> . condition statute
    (26) statute -> . return statute
    (27) statute -> . function statute
    (28) statute -> . write statute
    (29) statute -> . read statute
    (30) statute -> . empty
    (32) assignation -> . ID EQUAL expression SEMICOLON
    (33) assignation -> . access_array EQUAL expression SEMICOLON
    (34) decision -> . IF LPAREN expression_bool RPAREN THEN LBRACE statute RBRACE ELSE LBRACE def_else statute RBRACE
    (35) decision -> . IF LPAREN expression_bool RPAREN THEN LBRACE statute RBRACE
    (37) condition -> . WHILE LPAREN expression_bool_while RPAREN DO LBRACE statute RBRACE
    (46) return -> . RETURN LPAREN expression RPAREN
    (19) function -> . ID LPAREN era_function expression RPAREN
    (38) write -> . WRITE LPAREN expression RPAREN
    (39) read -> . READ LPAREN expression RPAREN
    (62) empty -> .
    (31) access_array -> . ID LBRACKET INT RBRACKET

    ID              shift and go to state 49
    IF              shift and go to state 51
    WHILE           shift and go to state 52
    RETURN          shift and go to state 53
    WRITE           shift and go to state 54
    READ            shift and go to state 55
    RBRACE          reduce using rule 62 (empty -> .)

    statute                        shift and go to state 160
    assignation                    shift and go to state 41
    decision                       shift and go to state 42
    condition                      shift and go to state 43
    return                         shift and go to state 44
    function                       shift and go to state 45
    write                          shift and go to state 46
    read                           shift and go to state 47
    empty                          shift and go to state 48
    access_array                   shift and go to state 50

state 159

    (36) def_else -> empty .

    ID              reduce using rule 36 (def_else -> empty .)
    IF              reduce using rule 36 (def_else -> empty .)
    WHILE           reduce using rule 36 (def_else -> empty .)
    RETURN          reduce using rule 36 (def_else -> empty .)
    WRITE           reduce using rule 36 (def_else -> empty .)
    READ            reduce using rule 36 (def_else -> empty .)
    RBRACE          reduce using rule 36 (def_else -> empty .)


state 160

    (34) decision -> IF LPAREN expression_bool RPAREN THEN LBRACE statute RBRACE ELSE LBRACE def_else statute . RBRACE

    RBRACE          shift and go to state 161


state 161

    (34) decision -> IF LPAREN expression_bool RPAREN THEN LBRACE statute RBRACE ELSE LBRACE def_else statute RBRACE .

    ID              reduce using rule 34 (decision -> IF LPAREN expression_bool RPAREN THEN LBRACE statute RBRACE ELSE LBRACE def_else statute RBRACE .)
    IF              reduce using rule 34 (decision -> IF LPAREN expression_bool RPAREN THEN LBRACE statute RBRACE ELSE LBRACE def_else statute RBRACE .)
    WHILE           reduce using rule 34 (decision -> IF LPAREN expression_bool RPAREN THEN LBRACE statute RBRACE ELSE LBRACE def_else statute RBRACE .)
    RETURN          reduce using rule 34 (decision -> IF LPAREN expression_bool RPAREN THEN LBRACE statute RBRACE ELSE LBRACE def_else statute RBRACE .)
    WRITE           reduce using rule 34 (decision -> IF LPAREN expression_bool RPAREN THEN LBRACE statute RBRACE ELSE LBRACE def_else statute RBRACE .)
    READ            reduce using rule 34 (decision -> IF LPAREN expression_bool RPAREN THEN LBRACE statute RBRACE ELSE LBRACE def_else statute RBRACE .)
    RBRACE          reduce using rule 34 (decision -> IF LPAREN expression_bool RPAREN THEN LBRACE statute RBRACE ELSE LBRACE def_else statute RBRACE .)

